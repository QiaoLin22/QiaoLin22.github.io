<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
          <li class = "link"><a href = "./leetcode4.html">4</a></li>
          <li class = "link"><a href = "./leetcode5.html">5</a></li>
          <li class = "link"><a href = "./leetcode6.html">6</a></li>
          <li class = "link"><a href = "./leetcode7.html">7</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/maximum-product-of-word-lengths/ target="blank" class = "leetcodelink">
                    318. Maximum Product of Word Lengths
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                Optimize noCommonLetters function : Bitmasks + Precomputation
            </ul>
            <h3>思路整理：</h3>
            <p>
                此题关键点在于如何判断两个string没有重复的字符，使用了一个巧妙的方法，即bitmasks。对于words中的每个word，我们用一个32位的bitmask来记录出现过哪些字符，具体做法为对word里的每个字符c，进行masks[i] |= 1 << c - 'a'操作。masks是一个长度为words的数组，专门用来存放bitmask。
                c - 'a'是为了将字符转换对对应的数字（到a的距离），然后通过将1左移相应次数将bitmask中对应位置变为1，在通过 ｜= 操作更新bitmask对应位置。举个例子，abc会被转换为111，即a位置，b位置和c位置均出现过。通过将每个word转换为bitmask我们可以o（1）时间判断两个string是否有重复字符，
                这就是bitmask操作的主要目的。之后剩下的就是找到最大长度，遍历所有两两组合，在不重复字符的情况下更新max即可，最后返回max。用bitmask表示字母字符串是此题的要点。
            </p>    
            <img src = "./src/images/leetcode318.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/bulb-switcher/ target="blank" class = "leetcodelink">
                    319. Bulb Switcher
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                寻找奇数个因数的数字个数
            </ul>
            <h3>思路整理：</h3>
            <p>
                一道数论题，最后还on的灯一定只有奇数个质因数，根据数论基础就是完全平方数，也就是此题让找出不大于n的完全平方数个数，直接返回sqrt（n）即可。
            </p>    
            <img src = "./src/images/leetcode319.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/generalized-abbreviation/ target="blank" class = "leetcodelink">
                    320. Generalized Abbreviation
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                backtracking
            </ul>
            <h3>思路整理：</h3>
            <p>
               典型backtrack题型，tricky的地方在于怎么把abbreviation和字母分开track，标答使用了一个单独的变量count用来记录目前abbreviation的数量。在backtrack时我们对每一个字母有两种处理方式，abbreviate和不abbreviate。abbreviate的话自然count++，
               count就是用来track当前abbreviation个数的用的，同时index+1后进入backtracking。另一种选择自然是不使用abbreviation，此时需要先把当前的（之前积攒的）count也就是abbreviation数加入cur，然后再将当前字母加入cur，再将count清零从新计数。完成这一系列
               操作后才能进入backtracking。终止条件为index达到末尾也就是word.length()，此时先将count加入cur，再将cur加入答案，最后返回答案即可。
            </p>    
            <img src = "./src/images/leetcode320.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/coin-change/ target="blank" class = "leetcodelink">
                    322. Coin Change
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
               dp
            </ul>
            <h3>思路整理：</h3>
            <p>
               注意此题是经典dp题型，greedy是不可行的，反例很容易找出不再赘述。dp的思路也很直接，使用bottom up的基本思想，从前n个位置推导出第n+1个位置的值。先创建一个dp数组长度为n+1表示每个amount最少用多少枚硬币可以组成。dp【0】自然为0，即不需要硬币就可以组合。从amount1到amountn就
               进入dp主循环，每次更新一个位置（根据coins数组和dp数组前面已有位置信息）。对于每一个新位置dp【i】先将它的值设置为maxvalue，然后遍历coins数组，当i >= coins[j]并且dp[i - coins[j]] != Integer.MAX_VALUE 时更新dp【i】
               值为Math.min(dp[i],dp[i-coins[j]]+1)。注意两个条件必须全部满足，第一个不满足会引起出界错误，第二个则是为了确保之前的位置确实是有值的不引起跟新混乱。这样每个dp【i】都被确实跟新为从前面amount可以使用一枚硬币达到时的硬币数，并且该值一定是全局最少的。遍历结束后我们直接判断
               dp[amount]是否是dummy value（maxvalue），若是则没有组合可以达到amount返回-1，否则返回dp【amount】的值即可。
            </p>    
            <img src = "./src/images/leetcode322.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/ target="blank" class = "leetcodelink">
                    323. Number of Connected Components in an Undirected Graph
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
               <li>dfs recursive</li>
               <li>bfs iterative</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               典型图搜索题，自然是dfs recursive 和 bfs iterative都可以。首先建立adjlist，使用常见的map实现即可。为了避免重复和无限循环，还是经典的visited set存储已经搜索过的node。接着就可以开始搜索，先看dfs。从0开始遍历所有的node，若该node没有被搜索过则代表着一块全新的componet，res++后
               进入dfs搜索。dfs方法内部也是经典操作，先将当前node加入visited，然后从adjlist中拿到当前node全部neighbours，遍历并将其中未被搜索过（不再visited中）的beighbour进行递归dfs搜索，所有搜索结束后回到主方法，返回res即可。bfs使用传统的queue来进行iteration，还是对0到n-1所有node进行遍历，
               若node未被搜索过，将node加入visited，res++后进入bfs搜索，在queue不为空时不断将当前node的邻居（为搜索过）加入队列。所有搜索结束后返回res。
            </p>    
            <img src = "./src/images/leetcode323-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode323-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/wiggle-sort-ii/ target="blank" class = "leetcodelink">
                    324. Wiggle Sort II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
               dp
            </ul>
            <h3>思路整理：</h3>
            <p>
               标答采用了215题 quickselect的思想来partition原数组后通过交换达到目的，以达到时间o（n）空间o（1）。这里看一个空间o（n）但是更自然简单的解法。首先创建一个数组复制，排序复制数组copy，之后选取中位数所在index将数组partition成两部分。选取左半部分最后一个index作为left，有半部分最后一个index
               作为right，遍历原数组，将偶数位置更改为copy【left】，奇数位置更改为copy【right】，每修改一个位置left或者right对应--。一轮修改完成后原数组必然符合wiggle sort要求，且时间方面和quickselect相差不大。
            </p>    
            <img src = "./src/images/leetcode324.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/ target="blank" class = "leetcodelink">
                    325. Maximum Size Subarray Sum Equals k
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
               one pass + hashmap cache
            </ul>
            <h3>思路整理：</h3>
            <p>
               评论区提供的巧妙思路，一轮遍历每次记录截止到index i之前的数字总合并将i之前总合和indexi记录到hashmap中cache起来。遍历中有两种情况需要更新max，第一种是从index 0开始到i的总合恰好是要找的target，此时更新max为截止到当前的最大距离。第二种情况是index i之前总合sum和map中存贮的之前某index j之前的
               总合之差是我们要找的数字，此时j到i之间的subarray也满足总合为target的要求，因此更新max为当前max和i-map.get(sum-target)中的较大者。除了这两种情况更新以外还需要在出现一个map中没出现过的key（截止到某index总合）时将该key和index存入map中，注意出现过的key不再更新的原因是我们希望找的是最大距离，保留
               最先出现的key恰好使得后续总合减去相对早出现的index总合满足要求时距离差距最大。一轮更新完成后返回max即可。
            </p>    
            <img src = "./src/images/leetcode325.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=hhttps://leetcode.com/problems/power-of-three/ target="blank" class = "leetcodelink">
                    326. Power of Three
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>naive</li>
              <li>base change + re</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               后两种方法有些fancy，实用性不强。主要看第二种方法，第一种方法就是普通的recursion，n非0时只有不停/3最后得到1才是3的幂。第二种方法需要注意的是java中常见的用于转换base的api，String baseChange = Integer.toString(number, base)。该api可以将任何n转换成想要的base并以string形式保存。除此之外就是
               正则表达式的运用，^1表示string以1开始，0*表示跟上0个或者若干个0，$表示没有其他字符出现。显而易见三的幂string形式正是匹配上述正则的唯一可能性，因此直接返回转换base后的字符串是否匹配上述正则即可。
            </p>    
            <img src = "./src/images/leetcode326.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/odd-even-linked-list/ target="blank" class = "leetcodelink">
                    328. Odd Even Linked List
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>Put the odd nodes in a linked list and the even nodes in another. Then link the evenList to the tail of the oddList.</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               思路很直接，将所有奇数位置node的next链接指向下一个奇数node，所有偶数node的next指向下一个偶数node，最后再将奇数node串接上偶数node串即可。我们以第一个even node作为基准遍历一轮，并在途中修改所有链接。当even不为空且他的下一个位置也不为空时（否则空指针），将odd的next指向此时even的next，将奇数node链接修改好，
               接着移动odd到下一个odd位置，此时even的next正是此时的odd的next位置，修改even的next为此时odd的next，然后移动even到下一个even位置，一轮修改就完成了。循环修改好所有链接后，将evenhead接在odd后面，然后返回head（其实就是oddhead）即可。
            </p>    
            <img src = "./src/images/leetcode328.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/ target="blank" class = "leetcodelink">
                    331. Verify Preorder Serialization of a Binary Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li></li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               此题技巧性比较强，结合了图论思想。在我们preorder遍历时保持对一个slot变量的计数，slot初始值为1，遇到任何一个节点（空或者非空）该值都-1，而后分类讨论，每当遇到的是一个非空节点时slot数+2，遇到空节点时不改变。如果严格遵循preorder左中右的顺序，那么traverse过程中该slot数量一定不会小于0，因此我们可以在traverse时加一个
               判断，任何时刻如果slot小于0则说明顺序有误，一定不是preorder，返回false。而最后traverse完毕时该slot变量一定变为0，如果变为0返回true，否则返回false。
            </p>    
            <img src = "./src/images/leetcode331.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/reconstruct-itinerary/ target="blank" class = "leetcodelink">
                    332. Reconstruct Itinerary
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>Hierholzer's Algorithm</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               虽然叫做Hierholzer's Algorithm，但引用答案的解释其实就是postorder DFS (Depth-First Search) in a directed graph, from a fixed starting point（jfk）。为了保证顺序我们构建adjlist时使用priorityqueue来存放一个node的neighbours即可。之后从jfk出发开始postorder dfs搜索，在当前node的neighbours不为空
               时，从当前node neighbours中删除最小neighbour，并对该neighbour进行递归dfs搜索，在dfs搜索最后将dfs起点node反向加入答案即可。
            </p>    
            <img src = "./src/images/leetcode332.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/largest-bst-subtree/ target="blank" class = "leetcodelink">
                    333. Largest BST Subtree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>top down || bottom up traversal, check, count</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               使用top down 代码最简便但是复杂度为n方。isvalid方法top down检查一棵树是否为bst（通过上下界check）而count方法数一颗bst的node个数用于返回答案。最后在主方法中top down递归找出第一课出现的bst，并通过count方法返回它的个数。可见该方法进行了多次重复计算，使用bottom up traverse配合自定义的类（同时check和count）可以将速度
                提升到o（n）。
            </p>    
            <img src = "./src/images/leetcode333.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>