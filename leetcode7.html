<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
          <li class = "link"><a href = "./leetcode4.html">4</a></li>
          <li class = "link"><a href = "./leetcode5.html">5</a></li>
          <li class = "link"><a href = "./leetcode6.html">6</a></li>
          <li class = "link"><a href = "./leetcode7.html">7</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/maximum-product-of-word-lengths/ target="blank" class = "leetcodelink">
                    318. Maximum Product of Word Lengths
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                Optimize noCommonLetters function : Bitmasks + Precomputation
            </ul>
            <h3>思路整理：</h3>
            <p>
                此题关键点在于如何判断两个string没有重复的字符，使用了一个巧妙的方法，即bitmasks。对于words中的每个word，我们用一个32位的bitmask来记录出现过哪些字符，具体做法为对word里的每个字符c，进行masks[i] |= 1 << c - 'a'操作。masks是一个长度为words的数组，专门用来存放bitmask。
                c - 'a'是为了将字符转换对对应的数字（到a的距离），然后通过将1左移相应次数将bitmask中对应位置变为1，在通过 ｜= 操作更新bitmask对应位置。举个例子，abc会被转换为111，即a位置，b位置和c位置均出现过。通过将每个word转换为bitmask我们可以o（1）时间判断两个string是否有重复字符，
                这就是bitmask操作的主要目的。之后剩下的就是找到最大长度，遍历所有两两组合，在不重复字符的情况下更新max即可，最后返回max。用bitmask表示字母字符串是此题的要点。
            </p>    
            <img src = "./src/images/leetcode318.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/bulb-switcher/ target="blank" class = "leetcodelink">
                    319. Bulb Switcher
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                寻找奇数个因数的数字个数
            </ul>
            <h3>思路整理：</h3>
            <p>
                一道数论题，最后还on的灯一定只有奇数个质因数，根据数论基础就是完全平方数，也就是此题让找出不大于n的完全平方数个数，直接返回sqrt（n）即可。
            </p>    
            <img src = "./src/images/leetcode319.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/generalized-abbreviation/ target="blank" class = "leetcodelink">
                    320. Generalized Abbreviation
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                backtracking
            </ul>
            <h3>思路整理：</h3>
            <p>
               典型backtrack题型，tricky的地方在于怎么把abbreviation和字母分开track，标答使用了一个单独的变量count用来记录目前abbreviation的数量。在backtrack时我们对每一个字母有两种处理方式，abbreviate和不abbreviate。abbreviate的话自然count++，
               count就是用来track当前abbreviation个数的用的，同时index+1后进入backtracking。另一种选择自然是不使用abbreviation，此时需要先把当前的（之前积攒的）count也就是abbreviation数加入cur，然后再将当前字母加入cur，再将count清零从新计数。完成这一系列
               操作后才能进入backtracking。终止条件为index达到末尾也就是word.length()，此时先将count加入cur，再将cur加入答案，最后返回答案即可。
            </p>    
            <img src = "./src/images/leetcode320.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>