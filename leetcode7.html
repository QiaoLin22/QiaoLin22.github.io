<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
          <li class = "link"><a href = "./leetcode4.html">4</a></li>
          <li class = "link"><a href = "./leetcode5.html">5</a></li>
          <li class = "link"><a href = "./leetcode6.html">6</a></li>
          <li class = "link"><a href = "./leetcode7.html">7</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/maximum-product-of-word-lengths/ target="blank" class = "leetcodelink">
                    318. Maximum Product of Word Lengths
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                Optimize noCommonLetters function : Bitmasks + Precomputation
            </ul>
            <h3>思路整理：</h3>
            <p>
                此题关键点在于如何判断两个string没有重复的字符，使用了一个巧妙的方法，即bitmasks。对于words中的每个word，我们用一个32位的bitmask来记录出现过哪些字符，具体做法为对word里的每个字符c，进行masks[i] |= 1 << c - 'a'操作。masks是一个长度为words的数组，专门用来存放bitmask。
                c - 'a'是为了将字符转换对对应的数字（到a的距离），然后通过将1左移相应次数将bitmask中对应位置变为1，在通过 ｜= 操作更新bitmask对应位置。举个例子，abc会被转换为111，即a位置，b位置和c位置均出现过。通过将每个word转换为bitmask我们可以o（1）时间判断两个string是否有重复字符，
                这就是bitmask操作的主要目的。之后剩下的就是找到最大长度，遍历所有两两组合，在不重复字符的情况下更新max即可，最后返回max。用bitmask表示字母字符串是此题的要点。
            </p>    
            <img src = "./src/images/leetcode318.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/bulb-switcher/ target="blank" class = "leetcodelink">
                    319. Bulb Switcher
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                寻找奇数个因数的数字个数
            </ul>
            <h3>思路整理：</h3>
            <p>
                一道数论题，最后还on的灯一定只有奇数个质因数，根据数论基础就是完全平方数，也就是此题让找出不大于n的完全平方数个数，直接返回sqrt（n）即可。
            </p>    
            <img src = "./src/images/leetcode319.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/generalized-abbreviation/ target="blank" class = "leetcodelink">
                    320. Generalized Abbreviation
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                backtracking
            </ul>
            <h3>思路整理：</h3>
            <p>
               典型backtrack题型，tricky的地方在于怎么把abbreviation和字母分开track，标答使用了一个单独的变量count用来记录目前abbreviation的数量。在backtrack时我们对每一个字母有两种处理方式，abbreviate和不abbreviate。abbreviate的话自然count++，
               count就是用来track当前abbreviation个数的用的，同时index+1后进入backtracking。另一种选择自然是不使用abbreviation，此时需要先把当前的（之前积攒的）count也就是abbreviation数加入cur，然后再将当前字母加入cur，再将count清零从新计数。完成这一系列
               操作后才能进入backtracking。终止条件为index达到末尾也就是word.length()，此时先将count加入cur，再将cur加入答案，最后返回答案即可。
            </p>    
            <img src = "./src/images/leetcode320.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/coin-change/ target="blank" class = "leetcodelink">
                    322. Coin Change
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
               dp
            </ul>
            <h3>思路整理：</h3>
            <p>
               注意此题是经典dp题型，greedy是不可行的，反例很容易找出不再赘述。dp的思路也很直接，使用bottom up的基本思想，从前n个位置推导出第n+1个位置的值。先创建一个dp数组长度为n+1表示每个amount最少用多少枚硬币可以组成。dp【0】自然为0，即不需要硬币就可以组合。从amount1到amountn就
               进入dp主循环，每次更新一个位置（根据coins数组和dp数组前面已有位置信息）。对于每一个新位置dp【i】先将它的值设置为maxvalue，然后遍历coins数组，当i >= coins[j]并且dp[i - coins[j]] != Integer.MAX_VALUE 时更新dp【i】
               值为Math.min(dp[i],dp[i-coins[j]]+1)。注意两个条件必须全部满足，第一个不满足会引起出界错误，第二个则是为了确保之前的位置确实是有值的不引起跟新混乱。这样每个dp【i】都被确实跟新为从前面amount可以使用一枚硬币达到时的硬币数，并且该值一定是全局最少的。遍历结束后我们直接判断
               dp[amount]是否是dummy value（maxvalue），若是则没有组合可以达到amount返回-1，否则返回dp【amount】的值即可。
            </p>    
            <img src = "./src/images/leetcode322.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/ target="blank" class = "leetcodelink">
                    323. Number of Connected Components in an Undirected Graph
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
               <li>dfs recursive</li>
               <li>bfs iterative</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               典型图搜索题，自然是dfs recursive 和 bfs iterative都可以。首先建立adjlist，使用常见的map实现即可。为了避免重复和无限循环，还是经典的visited set存储已经搜索过的node。接着就可以开始搜索，先看dfs。从0开始遍历所有的node，若该node没有被搜索过则代表着一块全新的componet，res++后
               进入dfs搜索。dfs方法内部也是经典操作，先将当前node加入visited，然后从adjlist中拿到当前node全部neighbours，遍历并将其中未被搜索过（不再visited中）的beighbour进行递归dfs搜索，所有搜索结束后回到主方法，返回res即可。bfs使用传统的queue来进行iteration，还是对0到n-1所有node进行遍历，
               若node未被搜索过，将node加入visited，res++后进入bfs搜索，在queue不为空时不断将当前node的邻居（为搜索过）加入队列。所有搜索结束后返回res。
            </p>    
            <img src = "./src/images/leetcode323-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode323-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/wiggle-sort-ii/ target="blank" class = "leetcodelink">
                    324. Wiggle Sort II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
               dp
            </ul>
            <h3>思路整理：</h3>
            <p>
               标答采用了215题 quickselect的思想来partition原数组后通过交换达到目的，以达到时间o（n）空间o（1）。这里看一个空间o（n）但是更自然简单的解法。首先创建一个数组复制，排序复制数组copy，之后选取中位数所在index将数组partition成两部分。选取左半部分最后一个index作为left，有半部分最后一个index
               作为right，遍历原数组，将偶数位置更改为copy【left】，奇数位置更改为copy【right】，每修改一个位置left或者right对应--。一轮修改完成后原数组必然符合wiggle sort要求，且时间方面和quickselect相差不大。
            </p>    
            <img src = "./src/images/leetcode324.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/maximum-size-subarray-sum-equals-k/ target="blank" class = "leetcodelink">
                    325. Maximum Size Subarray Sum Equals k
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
               one pass + hashmap cache
            </ul>
            <h3>思路整理：</h3>
            <p>
               评论区提供的巧妙思路，一轮遍历每次记录截止到index i之前的数字总合并将i之前总合和indexi记录到hashmap中cache起来。遍历中有两种情况需要更新max，第一种是从index 0开始到i的总合恰好是要找的target，此时更新max为截止到当前的最大距离。第二种情况是index i之前总合sum和map中存贮的之前某index j之前的
               总合之差是我们要找的数字，此时j到i之间的subarray也满足总合为target的要求，因此更新max为当前max和i-map.get(sum-target)中的较大者。除了这两种情况更新以外还需要在出现一个map中没出现过的key（截止到某index总合）时将该key和index存入map中，注意出现过的key不再更新的原因是我们希望找的是最大距离，保留
               最先出现的key恰好使得后续总合减去相对早出现的index总合满足要求时距离差距最大。一轮更新完成后返回max即可。
            </p>    
            <img src = "./src/images/leetcode325.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=hhttps://leetcode.com/problems/power-of-three/ target="blank" class = "leetcodelink">
                    326. Power of Three
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>naive</li>
              <li>base change + re</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               后两种方法有些fancy，实用性不强。主要看第二种方法，第一种方法就是普通的recursion，n非0时只有不停/3最后得到1才是3的幂。第二种方法需要注意的是java中常见的用于转换base的api，String baseChange = Integer.toString(number, base)。该api可以将任何n转换成想要的base并以string形式保存。除此之外就是
               正则表达式的运用，^1表示string以1开始，0*表示跟上0个或者若干个0，$表示没有其他字符出现。显而易见三的幂string形式正是匹配上述正则的唯一可能性，因此直接返回转换base后的字符串是否匹配上述正则即可。
            </p>    
            <img src = "./src/images/leetcode326.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/odd-even-linked-list/ target="blank" class = "leetcodelink">
                    328. Odd Even Linked List
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>Put the odd nodes in a linked list and the even nodes in another. Then link the evenList to the tail of the oddList.</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               思路很直接，将所有奇数位置node的next链接指向下一个奇数node，所有偶数node的next指向下一个偶数node，最后再将奇数node串接上偶数node串即可。我们以第一个even node作为基准遍历一轮，并在途中修改所有链接。当even不为空且他的下一个位置也不为空时（否则空指针），将odd的next指向此时even的next，将奇数node链接修改好，
               接着移动odd到下一个odd位置，此时even的next正是此时的odd的next位置，修改even的next为此时odd的next，然后移动even到下一个even位置，一轮修改就完成了。循环修改好所有链接后，将evenhead接在odd后面，然后返回head（其实就是oddhead）即可。
            </p>    
            <img src = "./src/images/leetcode328.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/ target="blank" class = "leetcodelink">
                    331. Verify Preorder Serialization of a Binary Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li></li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               此题技巧性比较强，结合了图论思想。在我们preorder遍历时保持对一个slot变量的计数，slot初始值为1，遇到任何一个节点（空或者非空）该值都-1，而后分类讨论，每当遇到的是一个非空节点时slot数+2，遇到空节点时不改变。如果严格遵循preorder左中右的顺序，那么traverse过程中该slot数量一定不会小于0，因此我们可以在traverse时加一个
               判断，任何时刻如果slot小于0则说明顺序有误，一定不是preorder，返回false。而最后traverse完毕时该slot变量一定变为0，如果变为0返回true，否则返回false。
            </p>    
            <img src = "./src/images/leetcode331.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/reconstruct-itinerary/ target="blank" class = "leetcodelink">
                    332. Reconstruct Itinerary
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>Hierholzer's Algorithm</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               虽然叫做Hierholzer's Algorithm，但引用答案的解释其实就是postorder DFS (Depth-First Search) in a directed graph, from a fixed starting point（jfk）。为了保证顺序我们构建adjlist时使用priorityqueue来存放一个node的neighbours即可。之后从jfk出发开始postorder dfs搜索，在当前node的neighbours不为空
               时，从当前node neighbours中删除最小neighbour，并对该neighbour进行递归dfs搜索，在dfs搜索最后将dfs起点node反向加入答案即可。
            </p>    
            <img src = "./src/images/leetcode332.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/largest-bst-subtree/ target="blank" class = "leetcodelink">
                    333. Largest BST Subtree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>top down || bottom up traversal, check, count</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               使用top down 代码最简便但是复杂度为n方。isvalid方法top down检查一棵树是否为bst（通过上下界check）而count方法数一颗bst的node个数用于返回答案。最后在主方法中top down递归找出第一课出现的bst，并通过count方法返回它的个数。可见该方法进行了多次重复计算，使用bottom up traverse配合自定义的类（同时check和count）可以将速度
                提升到o（n）。
            </p>    
            <img src = "./src/images/leetcode333.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/increasing-triplet-subsequence/ target="blank" class = "leetcodelink">
                    334. Increasing Triplet Subsequence
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>one pass two pointers</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                用dp也可以解决但是复杂度高于o（n），答案给出的思路比较巧妙，既然要寻找一个长度为3的递增subsequence，我们维护两个指针，一个指向当前遇到的最小的数字min，一个指向当前遇到的第二小的数字secmin。在一轮遍历过程中，每当遇到一个小于小于min的数字则替换min成为最小数字，secmin同理但不能和min是同一个数字。在遍历过程中，如果出现不同于
                min和secmin的第三个数字，并且该数字大于min和secmin，则该数字和min以及secmin必然构成一个长度为3的subsequence，也就是找到了这样一个subsequence，返回true。如果一轮遍历结束这样的数字依旧没有出现则整个数组中必然没有满足要求的subsequence，返回false即可。
            </p>    
            <img src = "./src/images/leetcode334.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=hhttps://leetcode.com/problems/house-robber-iii/ target="blank" class = "leetcodelink">
                    337. House Robber III
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>top down with cache</li>
              <li>dp</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                top down结合cache思路是经典解法，对于每个node我们有两种情况，rob它和不rob它，如果rob那么两个子节点就不能rob，最大值就是root值+左子节点两个子节点最大值总合+右子节点两个子节点最大值总合（左右子节点非空），递归调用四个孙子节点。此时得到rob root时的最大值。不rob root的最大值则是递归调用左右子节点结果的总合。root node处的最终
                结果就是两种情况中的最大者，最后返回该结果即可。为了避免重复计算我们用map存贮见过的节点，当再次来到计算过的节点时直接返回结果，复杂度从n方降低为n，但依旧是top down。为了从算法上就避免重复的可能性，我们可以在计算节点时就将rob该节点和不rob两种情况的最大值同时存贮起来，答案使用了一个长度为2的数组来存贮。此时同样是两种情况，不rob
                root时，左右子节点可以选择rob或者不rob，我们取两个节点两种情况中的最大值之和，即Math.max(left[0],left[1]) + Math.max(right[0],right[1])，作为res【0】。rob root时两个子节点只能选择不rob，此时最大值为root.val + left[0] + right[0】。最后返回整个树root处数组两个位置中最大值即可。
            </p>    
            <img src = "./src/images/leetcode337.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode337-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/counting-bits/ target="blank" class = "leetcodelink">
                    338. Counting Bits
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>DP + Least Significant Bit</li>
              <li>DP + Last Set Bit</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                看两种dp的思路，都是根据之前的数1的个数推出当前数1的个数。假设当前推理到n中1的个数，第一种思路是基于（n/2）的二进制表示恰好是n二进制表示去掉Least Significant Bit得到的。那么n的个数可以直接从（n/2）继承除了最后一位其他1的个数，然后根据最后一位是0还是1判断是否+1。最后一位可以直接通过（n % 2）得出。也就是通项公式可以归纳为
                ans[i] = ans[i >> 1] + (i & 1)。第二种思路是基于n & n-1可以得到n将Last Set Bit 变为0的二进制表示为基础，从dp【n&n-1】去推出dp【n】，而dp【n】自然是前者+1。通项公式归纳为ans[i] = ans[i & (i - 1)] + 1。有了通项公式后dp自然也就完成了，dp【0】也就是0中1个数为0，后续全部通过通项公式推出即可。
            </p>    
            <img src = "./src/images/leetcode338-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode338-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/nested-list-weight-sum/ target="blank" class = "leetcodelink">
                    339. Nested List Weight Sum
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>recursion</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                题目给出了一个自定义的类型nestedinteger，并提供了一系列接口，包括判断nestedinteger是否是一个数字（int），如果是拿到该数字，判断是否是一个list，如果是则拿到该list。nested这个性质很契合recursion的思路，我们在每一层中计算每个数字和它们depth的乘积，并通过一个辅助方法计算每一层的深度。最后返回从给定list的第一层递归调用结果
                即可。对于每一层，遍历该层所有的nestedinteger，如果是int，则将它的值和depth乘积加入sum，如果是list则递归调用该list并将结果加入sum，最后返回该层的sum。这样从原始list和depth 1开始递归后返回所有nestedlist的sum总合
            </p>    
            <img src = "./src/images/leetcode339.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/flatten-nested-list-iterator/ target="blank" class = "leetcodelink">
                    341. Flatten Nested List Iterator
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>recursion + queue</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                此题可以用queue或者stack实现，这里选择queue因为认为简单些。总体思路是用一个queue（integer）和一个recursive flatten方法将原始 nestedList flatten，也就是变成一个全部为integer类型的queue，并且由于queue性质，取出时顺序符合题目要求。queue完成后hasnext方法只需要判断queue是否为空即可，而next方法则根据hasnext返回值
                返回queue。pop（）值或者null。flatten方法和339题一直，顺序遍历所有list中的nestedinteger，如果已经是interger直接入队，否则递归调用该sublist，直到所有integer都被flatten并顺序入队。
            </p>    
            <img src = "./src/images/leetcode341.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/power-of-four/ target="blank" class = "leetcodelink">
                    342. Power of Four
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
              <li>count 0 in binary</li>
              <li>use bit mask</li>
              <li>math</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                首先2的power很好判断是需要n & n-1 == 0即可，关键在于区分2power和4power，拿8和16来举例。8是1000，16是10000，最直观的是0个数不一样，2power有奇数个0而4power有偶数个，可以根据这个来区分也就是方法一。第二种比较聪明，利用了现成的bit mask (101010...10)，即1在偶数位而0在奇数位.观察到4power的1在奇数位，因此自然有
                (num & 0xaaaaaaaa) == 0)这一判断条件（0xaaaaaaaa是bitmask的16进制表示）,0x55555555也可以，只要0或者1分别占据奇数位或者偶数位即可。最后一种方法利用了数论性质，观察到(4^k mod3)=((3+1)^k mod3) = 1， 因此power4在power2的基础上必须mod 3余1，将此作为第二个条件即可。
                ​
            </p>    
            <img src = "./src/images/leetcode342.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>