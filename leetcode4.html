<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
          <li class = "link"><a href = "./leetcode4.html">4</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/reverse-words-in-a-string/ target="blank" class = "leetcodelink">
                    151. Reverse Words in a String
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>split</li>
                <li>split</li>
                <li>deque</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                答案第三种采用了deque+stringbuilder的方法。图中采用了完全相同的逻辑但是使用了传统的string拼接方法。总体逻辑为先去掉首尾的whitespace，调用trim api或者手动去都可以。之后遍历string，设置一个局部string temp代表每一个word，当遇到一个非空格
                字母时向temp中写入这个字母，当遇到一个空格时说明一个word结束，将temp中的内容写入答案，将temp设置为空继续寻找下一个word。
            </p>
            <img src = "./src/images/leetcode151.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/maximum-product-subarray/ target="blank" class = "leetcodelink">
                    152. Maximum Product Subarray
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                经典dp题型，与以往dp不同的是我们这次在对数组进行遍历时不仅要记录局部最大值，还要同时记录局部最小值，因为对数组稍作观察就会发现两个很大的负数乘积会成为新的局部最大值，如果不做记录我们就得不到这种情况下产生的最大值。明确了这个核心思想
                就可以开始dp了，初始值max，min，result都设置为数组第一个元素，从第二个元素开始dp。此时有两种情况可以帮助思路更加清晰，第一碰到一个非负数，此时max可能变得更大，min也可能变得更小。max从之前的max乘以cur一定会变得更大（或者持平），而min乘以cur也
                一定会变得更小（或持平），原因在于当前看到的数字是非负的。我们相应更新min和max即可。另一种情况，看到当前数字是个负数。此时max变得更大只能是从之前的min乘以cur得到的，例如-2，3，-2中前两个数min为-6，再看到-2时max就变成-6*-2得到12。注意在更新
                max前需要把看到cur前的max记录下来用来更新min，例如-2，3时max为3，我们需要记录此时的max，在看到cur也就是-2时将就max和-2相乘得到新的min -6，原因是当看到一个负数cur时，新的min总是从之前的max和cur相乘得到的。这样我们对于数组每个数组都对max和min
                对应的更新，res自然就是记录max的全局最大值，也就是保留所有出现过的max局部最大值中的最大者。
            </p>
            <img src = "./src/images/leetcode152.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/ target="blank" class = "leetcodelink">
                    153. Find Minimum in Rotated Sorted Array
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>二分查找</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                经典二分查找题型，在这种数组有反转的情况下我们需要做的是将mid的值与数组两侧的值进行比较从而判断目标的相对位置进而移动start和end的位置。一开始使用mid和start比较但是发现做了无用的判断，因为题目是升序排列的所以更好的做法是将mid和end的值做比较从而达到一次
                就确定移动方向的目的。例如当mid大于start时我们无法判断最小值位置mid左侧还是右侧，就要进行二次判断。而当mid大于end值时说明最小值一定在mid右侧，因此将start更新为mid+1。同理当mid小于end时将end更改到mid位置。这里要注意不要将end更改到
                mid-1位置，因为此时我们只知道mid位置比end位置小，并没法判断mid是不是我们要找的最小值所以不能直接跳过mid，例如3，1，2中mid小于end如果直接将end更改为mid-1就把正确答案1直接跳过了，这一点要注意。循环结束时start和end都被移动到最小值处，返回nums【start】即可。
            </p>
            <img src = "./src/images/leetcode153.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/min-stack/ target="blank" class = "leetcodelink">
                    155. Min Stack
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>stack</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                此题我们不使用现成的stack而最好是自己定义需要的数据结构，观察发现我们需要的其实就是一个可以存储两个值min和val的linkedlist，我们在node class中加入min属性即可。实现minstack逻辑很简单，创建一个空的head节点，push时首先判断head是否为null，是的话创建一个新节点head，val和min都是x的值，
                不为空的话同样创建一个新节点。更新val和min，min为旧head的min和x中较小者，并将该节点的pre指向老head。pop时head节点向前移动一个，直接 head = head.pre即可。top和getmin分别返回head的val和min即可。
            </p>
            <img src = "./src/images/leetcode155.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/binary-tree-upside-down/submissions/ target="blank" class = "leetcodelink">
                    156. Binary Tree Upside Down
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                递归翻转树，首先判断根节点是否需要处理，当左右都不为空时需要翻转，否则返回null或者叶子节点。当需要翻转时，递归调用左子树并将结果保存为newroot，这将是翻转后的root。之后对每一个子树进行拼接，先将root.right拼接到root.left.left，再将root拼接到root.left.right就完成了子树的翻转。每次完成一个左子树的反转，
                由递归来完成整个树的翻转。
            </p>
            <img src = "./src/images/leetcode156.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/read-n-characters-given-read4/ target="blank" class = "leetcodelink">
                    157. Read N Characters Given Read4
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>一轮循环</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                很难懂一道题，简要概括了一下题目的意思。n是需要从file中读取的字符数，并不意味着file中字符就是那么多个，真正的file里有多少个字符我们不知道。我们读取file只有一种方法就是通过read4 api每次读取四个字符并存放到一个数组中。我们还需要在每次读取后将获得的字符写入叫buf的数组中使得buf最后长度恰好为n。
                由于我们需要读取恰好n个字符写入buf，每次read4 api每次只能读取四个字符，所以我们需要在读取到n个字符时停止，此时read4中可能还有剩余的字符。例如file 内容为leetcode总共八个字符，但是我们只需要读取前五个，此时调用read4会读取两次拿到所有八个字符然而我们只需要前五个。因此我们只需要判断剩余字符
                数量是否小于4个，一旦小于说明我们已经拿到所需的n个字符，舍弃掉read4里剩余的字符并结束循环。我们设置一个计数器total记录已经读取了多少个字符，一个count表示此次读取我们将会写入buf（确实需要的）的字符数量，一旦（n-total）小于4个时我们知道已经读取了n个需要的字符，结束循环即可。读取和复制到buf的具体实现很简单，见代码。
            </p>
            <img src = "./src/images/leetcode157.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>