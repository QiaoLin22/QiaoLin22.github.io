<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
          <li class = "link"><a href = "./leetcode4.html">4</a></li>
          <li class = "link"><a href = "./leetcode5.html">5</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/contains-duplicate/ target="blank" class = "leetcodelink">
                    217. Contains Duplicate
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>hashset</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                本来以为有bit相关的巧解，结果就是普通的set记录duplicate，很简单的题。
            </p>    
            <img src = "./src/images/leetcode217.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/contains-duplicate-ii/ target="blank" class = "leetcodelink">
                    219. Contains Duplicate II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>hashmap</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                使用hashmap同时记录数字和他们出现的位置，遇到之前看到过的数字判断距离是否不超过k，是则直接返回true，否则更新map对应数字为新的位置。遇到没见过的则添加到hashmap。如果遍历数组结束依然没找到距离不超过k的则返回false。
            </p>    
            <img src = "./src/images/leetcode219.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/contains-duplicate-iii/ target="blank" class = "leetcodelink">
                    220. Contains Duplicate III
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>bst</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                首先题目要求两个位置距离不超过看，并且在这个基础上两个数字差值不能超过t。答案使用的思路是通过二叉查找树来维护一个大小为k的窗口，这个树使用treeset数据结构来达到自平衡的效果。每次新加入一个元素x我们就在窗口内查找x的successor，
                也就是大于x的最小数字与x差值是否在t以内，是的话return true，同时查找x的predecessor，也就是比x小的最大元素与x差值是否在t以内，是的话return true。如果加入x后窗口大小超过了k，移除窗口内最老的数子，也就是最早加入的数字来维护窗口
                大小不超过k。bst的思路适用于比较一定范围内数字任意两者间最小差值或者类似问题，因为ceiling和floor api 提供了比较一个数字和距离最近的上下邻居的简便途径。
            </p>    
            <img src = "./src/images/leetcode220.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/maximal-square/ target="blank" class = "leetcodelink">
                    221. Maximal Square
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                此题使用了一个巧妙的dp思路，根据原数组中1出现的位置通过dp一轮遍历来获得最大1矩阵的边长。具体方法为遍历原矩阵，构建长宽都大1的dp矩阵，每当原矩阵对应位置为1时（matrix[i-1][j-1] == '1'），更新dp矩阵i，j位置为dp[i-1][j-1]，
                dp[i-1][j]，和dp[i][j-1]即左上，左和上位置三者中的最小者+1，因此只有当矩阵全部由1构成时边长才回达到正确数值。在遍历中同时记录下出现过的最大边长，最后返回边长的平方即可。我们也可以使用一维度dp数组来进一步简化空间复杂度。
            </p>    
            <img src = "./src/images/leetcode221.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/count-complete-tree-nodes/ target="blank" class = "leetcodelink">
                    222. Count Complete Tree Nodes
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>binary search</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                普通recursion一个个计算node数量的思路容易想到，但就像答案所说的，这样做没有充分利用题目给出的complete binary tree这个条件。我们知道当一个树是complete的时候它的节点数可以直接用2的深度次方-1得出，我们可以利用这个公示结合题目给出的
                complete binary tree的条件将时间从o（n）进一步提升。我们可以通过计算左右子树的深度来判断该数是否是完整的，是的话直接用公式返回节点数，否的话递归调用该节点左右子树后+1得到总节点数。由于题目性质，每一层中总会至少有一颗完整的子数可以用
                公式直接返回，直到找到最底层最右边节点（导致深度不同的原因），所用时间和搜索特定节点时间相同为o（logn），而计算每层深度又需要o（logn）所以总时间为o（log^2n）。使用位运算而不是math pow计算2的幂的原因是位运算的速度要快上很多。
            </p>    
            <img src = "./src/images/leetcode222.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>