<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/symmetric-tree/ target="blank" class = "leetcodelink">
                    101. Symmetric Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                先来看递归，判断一棵树是否是对称的相当于判断这棵树在每一层左半部分所有节点是否都在右半部分对于位置存在一个镜像，为了方便判断一对节点是否互为镜像我们做一个辅助方法并将参数设置为两个节点，一开始放入辅助方法的是根节点的两个复制，
                之后递归地判断根节点处的一对镜像位置的值是否相等，一旦出现不想等的情况（包括一个为null）则返回false，所有镜像位置全部相等返回true。迭代的思路利用了老办法用stack数据结构来替代递归所起到的作用，首先将根节点左右两个节点入栈，
                之后在栈非空是进行循环每次拿到一对镜像位置，判断一下时候不想等，相等则继续将这一对镜像位置下一层的两对镜像位置入栈，本质上实现了dfs递归调用，当栈空是所有镜像位置都被判断为相等并返回true。
            </p>
            <img src = "./src/images/leetcode101-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode101-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/binary-tree-level-order-traversal/ target="blank" class = "leetcodelink">
                    102. Binary Tree Level Order Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                还是同样可以用递归和迭代两种方式解决，先来看递归。首先我们发现既然题目要求将同一层的节点放在一起，那我们必然需要在辅助方法中传入一个代表层数的参数来track递归到了哪一层，否则这个信息就无法跟踪。明确了helper method参数后
                我们就要思考如何根据层数信息来构建答案所需的这个二维数组，我们每一个level肯定要有一个对应的arraylist，以后每递归到相同的level就向这个arraylist动态添加数字，所以我们在递归方法中首先要判断有没有当前level所对应的那个arraylist，
                没有就创建出一个空的。具体来说是把level和当前的res。size（）做对比，level大于ressize就要创建一个空的待添加的arraylist。这样就保证了每一层都一定有一个对应的动态数组可以去添加。其他要做的就是通过arraylist的get方法拿到level对应的
                那一层然后添加，接着按照inorder顺序递归traverse树即可，因为题目对每层顺序有要求所以必须是inorder先左支后右支。迭代的思路十分类似，与之前不同的是我们需要使用队列而不是stack，因为我们需要在不破坏当前层顺序的前提下添加下一层。其他要做的
                就是在队列不为空时循环的将队列头部旧层的节点拿出，判断每一个节点左右是否为空并在非空时加入队列，先左后右的顺序不变。要拿到旧层每个节点只需要记录旧层节点总个数然后循环从队列头部poll那么多次即可，在每一层处理完毕后将该层节点数组加入答案。
            </p>
            <img src = "./src/images/leetcode102-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode102-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/ target="blank" class = "leetcodelink">
                    103. Binary Tree Zigzag Level Order Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                与上一题基本雷同，唯一的区别在于奇数层保持顺序而欧树层需要变为逆序，我们只需要一个变量来记录当前是奇数层还是偶数层然后在向答案中添加arraylist前根据这个变量判断是否需要反转数组即可。用boolean或者int均可，这里使用了int。评论区看到一种通过
                构建两个stack或者两个queue并每次修改添加的顺序从左节点右节点到右左来达到反转目的答案，是个有创意的思路。
            </p>
            <img src = "./src/images/leetcode103.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/maximum-depth-of-binary-tree/ target="blank" class = "leetcodelink">
                    104. Maximum Depth of Binary Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                递归比较容易想到，在任意一个节点处的最大深度可以总结为1+它左子树和右子树深度的较大者，当遇到空节点时返回深度0，其余情况递归调用1+max（root.left,root.right）即可。迭代法重用了前两题bfs的思路，用queue数据结构来实现每一层的bfs遍历。观察到
                queue每一轮循环实现了一个旧层节点全部从头部出队列，新层节点全部进队列的过程，这个过程结束时一层dfs即处理完毕也就意味着层数+1.我们可以用一个变量来记录层数的变化，初始值为0，在一轮bfs结束前++即可追踪层数的变化。queue为空也就是循环结束时该变化自然
                等于最大层数。
            </p>
            <img src = "./src/images/leetcode104-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode104-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ target="blank" class = "leetcodelink">
                    105. Construct Binary Tree from Preorder and Inorder Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               首先观察到要求时按照左中右顺序也就是preorder顺序来构建树，因此我们通过在preorder数组上的递归来构建出树，然而对于每个preorder中的节点，它左子树和右子树所包含的节点存储在inorder数组中，也就是我们需要用preorder的根节点结合inorder的左右子树来递归构建成
               完整的树。为了准确知道每个根节点左右子树包括哪些节点我们就需要四个指针以及一个map来实时跟踪这些信息。map用来存贮inorder数组的位置信息，避免每次都要单独搜索耽误时间（数组中搜索最快也要logn，map则是常数时间），因为每当我们拿到preorder中一个根节点时
               我们都需要知道该节点在inorder中的位置进而拿到左右子树节点信息。四个指针分别记录prestart，preend，instart，inend，prestart和preend初始值为0和preorder的length-1，之后每次递归时根据当前根节点左右子树各包含多少个节点来更新prestart和preend到对应位置。
               例如3左子树有一个节点9，右子树有三个节点，那么下一层递归就会分别被更新为（1，1）和（2，4），instart和inend也根据根节点位置被拆分成左子树和右子树分别包含的节点。可以理解为不停递归从preorder拿到根节点并从inorder拿到该节点左右子树的过程。
            </p>
            <img src = "./src/images/leetcode105.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ target="blank" class = "leetcodelink">
                    106. Construct Binary Tree from Inorder and Postorder Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               与上一题基本雷同，递归postorder数组，利用inorder来找到左右子树节点数进而在postorder进入下一层递归前更新其左右子树范围。不同的是因为是postorder所以更新时需要按照右子树节点数先更新右子树再更新左子树
            </p>
            <img src = "./src/images/leetcode106.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/binary-tree-level-order-traversal-ii/ target="blank" class = "leetcodelink">
                    107. Binary Tree Level Order Traversal II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               与102题基本雷同，答案直接使用了reverse方法，如果不使用reverse我们也可以每次将新的空list加入arraylist顶部而不是底部然后在添加数字时加在arraylist的size减去level的那一层达到一样的效果。
            </p>
            <img src = "./src/images/leetcode107.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ target="blank" class = "leetcodelink">
                    108. Convert Sorted Array to Binary Search Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              答案给出了选取左mid，右mid和randommid三种方法，其实感觉必要性不大，都按照start+（end-start）/2来定位mid即可，设置start，end两个参数初始值设置为数组两边，然后递归地将数组拆分为组成左子树的数组，
              root和组成右子树的数组，当start 大于 end时返回null即达到了叶子节点，其余情况每次将当前mid位置的值作为当前子树的root。递归创建左子树（start，mid-1）和右子树（mid+1，end）然后返回当前root。
            </p>
            <img src = "./src/images/leetcode108.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>