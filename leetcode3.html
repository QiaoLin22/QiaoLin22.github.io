<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/symmetric-tree/ target="blank" class = "leetcodelink">
                    101. Symmetric Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                先来看递归，判断一棵树是否是对称的相当于判断这棵树在每一层左半部分所有节点是否都在右半部分对于位置存在一个镜像，为了方便判断一对节点是否互为镜像我们做一个辅助方法并将参数设置为两个节点，一开始放入辅助方法的是根节点的两个复制，
                之后递归地判断根节点处的一对镜像位置的值是否相等，一旦出现不想等的情况（包括一个为null）则返回false，所有镜像位置全部相等返回true。迭代的思路利用了老办法用stack数据结构来替代递归所起到的作用，首先将根节点左右两个节点入栈，
                之后在栈非空是进行循环每次拿到一对镜像位置，判断一下时候不想等，相等则继续将这一对镜像位置下一层的两对镜像位置入栈，本质上实现了dfs递归调用，当栈空是所有镜像位置都被判断为相等并返回true。
            </p>
            <img src = "./src/images/leetcode101-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode101-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/binary-tree-level-order-traversal/ target="blank" class = "leetcodelink">
                    102. Binary Tree Level Order Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                还是同样可以用递归和迭代两种方式解决，先来看递归。首先我们发现既然题目要求将同一层的节点放在一起，那我们必然需要在辅助方法中传入一个代表层数的参数来track递归到了哪一层，否则这个信息就无法跟踪。明确了helper method参数后
                我们就要思考如何根据层数信息来构建答案所需的这个二维数组，我们每一个level肯定要有一个对应的arraylist，以后每递归到相同的level就向这个arraylist动态添加数字，所以我们在递归方法中首先要判断有没有当前level所对应的那个arraylist，
                没有就创建出一个空的。具体来说是把level和当前的res。size（）做对比，level大于ressize就要创建一个空的待添加的arraylist。这样就保证了每一层都一定有一个对应的动态数组可以去添加。其他要做的就是通过arraylist的get方法拿到level对应的
                那一层然后添加，接着按照inorder顺序递归traverse树即可，因为题目对每层顺序有要求所以必须是inorder先左支后右支。迭代的思路十分类似，与之前不同的是我们需要使用队列而不是stack，因为我们需要在不破坏当前层顺序的前提下添加下一层。其他要做的
                就是在队列不为空时循环的将队列头部旧层的节点拿出，判断每一个节点左右是否为空并在非空时加入队列，先左后右的顺序不变。要拿到旧层每个节点只需要记录旧层节点总个数然后循环从队列头部poll那么多次即可，在每一层处理完毕后将该层节点数组加入答案。
            </p>
            <img src = "./src/images/leetcode102-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode102-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/ target="blank" class = "leetcodelink">
                    103. Binary Tree Zigzag Level Order Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                与上一题基本雷同，唯一的区别在于奇数层保持顺序而欧树层需要变为逆序，我们只需要一个变量来记录当前是奇数层还是偶数层然后在向答案中添加arraylist前根据这个变量判断是否需要反转数组即可。用boolean或者int均可，这里使用了int。评论区看到一种通过
                构建两个stack或者两个queue并每次修改添加的顺序从左节点右节点到右左来达到反转目的答案，是个有创意的思路。
            </p>
            <img src = "./src/images/leetcode103.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/maximum-depth-of-binary-tree/ target="blank" class = "leetcodelink">
                    104. Maximum Depth of Binary Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                递归比较容易想到，在任意一个节点处的最大深度可以总结为1+它左子树和右子树深度的较大者，当遇到空节点时返回深度0，其余情况递归调用1+max（root.left,root.right）即可。迭代法重用了前两题bfs的思路，用queue数据结构来实现每一层的bfs遍历。观察到
                queue每一轮循环实现了一个旧层节点全部从头部出队列，新层节点全部进队列的过程，这个过程结束时一层dfs即处理完毕也就意味着层数+1.我们可以用一个变量来记录层数的变化，初始值为0，在一轮bfs结束前++即可追踪层数的变化。queue为空也就是循环结束时该变化自然
                等于最大层数。
            </p>
            <img src = "./src/images/leetcode104-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode104-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ target="blank" class = "leetcodelink">
                    105. Construct Binary Tree from Preorder and Inorder Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               首先观察到要求时按照左中右顺序也就是preorder顺序来构建树，因此我们通过在preorder数组上的递归来构建出树，然而对于每个preorder中的节点，它左子树和右子树所包含的节点存储在inorder数组中，也就是我们需要用preorder的根节点结合inorder的左右子树来递归构建成
               完整的树。为了准确知道每个根节点左右子树包括哪些节点我们就需要四个指针以及一个map来实时跟踪这些信息。map用来存贮inorder数组的位置信息，避免每次都要单独搜索耽误时间（数组中搜索最快也要logn，map则是常数时间），因为每当我们拿到preorder中一个根节点时
               我们都需要知道该节点在inorder中的位置进而拿到左右子树节点信息。四个指针分别记录prestart，preend，instart，inend，prestart和preend初始值为0和preorder的length-1，之后每次递归时根据当前根节点左右子树各包含多少个节点来更新prestart和preend到对应位置。
               例如3左子树有一个节点9，右子树有三个节点，那么下一层递归就会分别被更新为（1，1）和（2，4），instart和inend也根据根节点位置被拆分成左子树和右子树分别包含的节点。可以理解为不停递归从preorder拿到根节点并从inorder拿到该节点左右子树的过程。
            </p>
            <img src = "./src/images/leetcode105.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ target="blank" class = "leetcodelink">
                    106. Construct Binary Tree from Inorder and Postorder Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               与上一题基本雷同，递归postorder数组，利用inorder来找到左右子树节点数进而在postorder进入下一层递归前更新其左右子树范围。不同的是因为是postorder所以更新时需要按照右子树节点数先更新右子树再更新左子树
            </p>
            <img src = "./src/images/leetcode106.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/binary-tree-level-order-traversal-ii/ target="blank" class = "leetcodelink">
                    107. Binary Tree Level Order Traversal II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               与102题基本雷同，答案直接使用了reverse方法，如果不使用reverse我们也可以每次将新的空list加入arraylist顶部而不是底部然后在添加数字时加在arraylist的size减去level的那一层达到一样的效果。
            </p>
            <img src = "./src/images/leetcode107.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ target="blank" class = "leetcodelink">
                    108. Convert Sorted Array to Binary Search Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              答案给出了选取左mid，右mid和randommid三种方法，其实感觉必要性不大，都按照start+（end-start）/2来定位mid即可，设置start，end两个参数初始值设置为数组两边，然后递归地将数组拆分为组成左子树的数组，
              root和组成右子树的数组，当start 大于 end时返回null即达到了叶子节点，其余情况每次将当前mid位置的值作为当前子树的root。递归创建左子树（start，mid-1）和右子树（mid+1，end）然后返回当前root。
            </p>
            <img src = "./src/images/leetcode108.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/ target="blank" class = "leetcodelink">
                    109. Convert Sorted List to Binary Search Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              和上一题类似的逻辑，不过存贮节点的数据结构从array变为了linkedlist，也就导致我们不能通过index直接拿到mid处的值和左右两个子array了，我们需要用linkedlist的方式来解决这些问题。既然linkedlist不支持随机访问我们就只能从头开始找mid，
              我们怎么知道什么时候到达了mid位置呢，我们可以用双指针，一个快指针一个慢指针，快指针每次前进两个节点（不越界前提）而慢指针只前进一个节点。这样当快指针越界时慢指针就恰好指向mid处所在的位置。那么分离操作如何进行呢，我们有头部指针head，中部
              指针mid，那么mid。next就是后半部分链表，前半部分想要分离出来我们需要slow的前一个位置的指针，我们可以在之前找mid的循环中将这个prev指针一起定位好。设置prev初始值为空指针，每次在slow更新前将prev更新为slow即可。这样我们就拿到了slow结束时前面
              指针的位置，然后将该指针指向null就达到了断开前半部分链表的效果。注意判断prev非空，因为当slow没有移动时（链表长度为1）prev为空，调用pre的next会抛出npe异常。
            </p>
            <img src = "./src/images/leetcode109.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/balanced-binary-tree/ target="blank" class = "leetcodelink">
                    110. Balanced Binary Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>top down递归</li>
                <li>bottom up递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              top down递归比较明显，一个递归方法计算每个节点最大深度，主方法递归判断每个节点是否是平衡的，这样做的缺点是对树进行了重复递归，因为本质上每次调用平衡递归和最大深度递归是在对树的同一部分进行递归，有没有办法在计算最大深度的递归完成时就顺带着比较
              树是否平衡呢？观察到最大深度方法返回一个int而平衡返回一个boolean，这一点影响了我们将两个递归合并，那么我们可不可以用int来代替boolearn而达到同样的效果。我们可以在树平衡时正常递归计算树最大深度，而在不平衡时将节点的最大深度设置为-1。确保只在
              两棵子树都平衡时正常更新为max（leftmax，rightmax），一旦遇到一颗不平衡子树则该父节点最大深度也为-1.这样进行递归时一旦遇到任意一个节点不平衡时都将导致最终结果返回-1，这正是我们想达到的效果。我们只需要在递归返回时判断是否为-1即可判断整个树
              的平衡性。一次递归调用就解决所有问题而不是两个递归嵌套调用，节省了栈资源。
            </p>
            <img src = "./src/images/leetcode110.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/minimum-depth-of-binary-tree/ target="blank" class = "leetcodelink">
                    111. Minimum Depth of Binary Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              唯一一个要注意的点是当一个节点左子树或者右子树为空时，空的那边没有最小深度，不可以作为0去计算。观察到这两种特殊情况后就很简单了，当且仅当有一个子树为空时直接返回另一半子树的最小深度+1即可，空的那一边当作不存在处理。
            </p>
            <img src = "./src/images/leetcode111.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/path-sum/submissions/ target="blank" class = "leetcodelink">
                    112. Path Sum
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              同样可以妙用递归思想，递归树，每遇到一个非空节点就将当前sum值减去该节点值，当来到一个左右都为空且sum已经被减为0的节点时说明找到了这条path返回true，注意一边空一边非空时不返回，寻找还没有结束。其他情况均说明寻找没完成，
              递归寻找左右子树并在任意子树返回true时返回true，所以用｜｜连接。
            </p>
            <img src = "./src/images/leetcode112.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/path-sum/submissions/ target="blank" class = "leetcodelink">
                    113. Path Sum II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              跟上一题思路基本雷同，有几个额外的地方需要注意。第一点是在找到一条路径后想答案添加时需要添加一个新的arraylist并将cur复制进去达到深拷贝的效果。第二点是由于我们在递归中返回到上一层时cur并不会自动pop返回上层时的状态，
              我们需要在一个节点左右子树都寻找完时手动移除cur的最后一个（也就是刚刚探索完毕的那个节点）节点，否则每次cur加入答案时会带着之前寻找到目标之前找过的所有路径。
            </p>
            <img src = "./src/images/leetcode113.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ target="blank" class = "leetcodelink">
                    114. Flatten Binary Tree to Linked List
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              既然是树那么首先考虑递归的思路，先思考每一步要做什么。观察到不管左右支长成什么样子，我们要做的都是把一个根节点左子树剪下来，贴到右子树上，同时为了防止右子树丢失，提前存起来，然后接到之前添加好的新右子树的右子树，这样整个树就变成了一个完整的right skew的树。
              一个特殊情况为当一个根节点有左子树却没有右子树时,我们直接将左子树接到右边即可。当两个子树都非空时具体拼接方法如下，首先剪下左右子树并存贮，然后左子树变为空，右子树首先接上原左子树，接着为了找到新右子树的尾巴，用一个loop来寻找，找到末尾后接上原右子树。之后
              递归调用右子树即可。
            </p>
            <img src = "./src/images/leetcode114.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ target="blank" class = "leetcodelink">
                    116. Populating Next Right Pointers in Each Node
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>迭代on空间，queue</li>
                <li>迭代o1，no extra space</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              第一种方法沿用了传统的迭代level order traverse也就是使用queue的数据结构每次拿到一整层的node再依次连接起来，比较trivial不做讨论。第二种方法达到了no extra space并且方法十分的巧妙，重点研究一下。第二种思路的核心思想在于我们可以利用某一层已经连接好next
              的node在直接构建出下一层node所有next所需要的连接，观察到根节点恰好就是那个已经连接好next的层，所以我们可以顺次构建出第二层，在用同样逻辑从第二层构建第三层以此类推。那么具体每层如何构建出下一层呢，初始条件只有一个上一层第一个node，但是该node之后所有next已经
              被连接好了，相当于一个linkedlist，我们可以通过next来直接遍历这一层。再观察发现下一层的连接有两种情况，同parent两个节点连接以及来自两个上层相邻parent左节点和右节点连接，不论那种情况都可以通过上层直接连接。假设我们上层负责遍历的节点叫head，那么同parent下层
              节点可以直接用head.left.next = head.right连接。不同parent无外乎就是用head和head。next一起构建，也就是 head.right.next = head.next.left（注意判断head next非空）这样下层就连接完毕。同时我们从开始就维护一个每一层最左边的节点，leftmost作为每层
              遍历的起点，在一层连接完毕后直接更新leftmost为leftmost。left即可，因为这是一颗完整的二叉树所以leftmost。left不可能为空。这样从根节点开始每一层从leftmost（根节点leftmost就是自己）开始遍历构建出下层next连接然后更新leftmost到left也就是下层第一个节点就可以完成整棵树的所有连接。
            </p>
            <img src = "./src/images/leetcode116.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/ target="blank" class = "leetcodelink">
                    117. Populating Next Right Pointers in Each Node II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>迭代on空间，queue</li>
                <li>迭代o1，no extra space</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              答案第二种思路写的相当繁琐，推荐一种网上看到的递归思路。首先沿用上一题思路，通过上一层next连接来构建下层next连接。对于每一个点它的左子树可能为空，右子树也可能为空，我们就要分类讨论，首先判断左子树是否为空，非空就简单了，直接root.left.next = root.right。
              如果左边根本没有我们就不需要处理左分支了，递归到下一层即可。如果左边非空我们就要根据右子树情况判断当前最右边节点是rootleft还是rootright。之后在上层next中寻找rightmost的next节点，当上层next节点left非空时就连接到该节点，上层next的right非空时就连接到
              right，找到后理解结束循环。这样每一次递归我们都在尝试将该节点左右节点中非空的那个连接到下一个正确的位置。如此递归左右子树即可。
            </p>
            <img src = "./src/images/leetcode117.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/pascals-triangle/ target="blank" class = "leetcodelink">
                    118. Pascal's Triangle
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              从这个金字塔的形状很容易想到dp也就是从上一层构建出下一层，那么我们要先把第一层写好并将第一层当作dp的初始值，这样从第二层开始所有层都可以从上一层顺次得出。设置一个当前层数level为2，当level小于等于numrows时进入while循环，每次拿到上一层两个值并相加并在头尾
              添上1就等到了当前需要的这一层，将该层加入答案。这样循环结束时所有numrows层就都构建完毕。
            </p>
            <img src = "./src/images/leetcode118.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/pascals-triangle-ii/ target="blank" class = "leetcodelink">
                    119. Pascal's Triangle II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
                <li>dp memory efficient</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               这次我们只需要拿到最后一层而非所有的层，依然可以沿用上一题的思路从n层构建出n+1层，但这道题重点是如何节省空间，当然可以先构建整个金字塔（上题）然后只返回最底层，但是对空间造成了极大的浪费。先来看第一种较容易想到的dp，该思路从始至终只构建了两个arraylist res和pre，一个代表
               上层一个代表下层，res初始值只有一个1而pre为空，然后每次先用res构建出下一层，使res指向下一层，然后pre指向原res就完成了从n-1，n层到n，n+1层的转移，这样循环rowindex次res就指向了最底层。再看第二种dp思路，该思路从始至终只构建了一个arraylist，通过不断修改该arraylist直到
               拿到最底层，仅仅使用了必须的空间没有一点额外空间浪费。具体实现如下，初始arraylist大小直接设置为最终所需要的rowindex+1，并先添加一个1代表第一层。之后层从上层尾部开始逆向将上层j和j-1位置两两相加保留头部也就是1不变，最后在尾部添加1完成新层的构建。这样rowindex轮结束arraylist
               正是我们要的最底层。概括下就是方法1每次将旧arraylist构建并放到一个全新arraylist中，然后抛弃旧的。第二种方法是直接在原地将旧的改成新的而没有复制操作。
            </p>
            <img src = "./src/images/leetcode119-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode119-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/triangle/ target="blank" class = "leetcodelink">
                    120. Triangle
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>bottom up dp</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               一开始尝试top down dp但是失败了，因为当树中有负数时我们无法简单的通过当前节点和左右中最小的那一边来判断出正确路径，但是bottom up则不然，top down中当前最小路径不一定和下一层中最小的相连接，bottom up中从底下向上找时由于我们已经在底层穷尽了所有情况，所以只需要放心的将当前层中所有
               路径加进来即可。我们可以将dp数组初始值设置为最底层，因为此时底层自己就是到自己的的最短路径，没向上拿到一层，就将dp数组的前当前层个数个数据更新，更新方法为当前节点值加上上一层左右子节点中小的那一个。例如从第四层更新第三层时，根据第三层三个节点和它们分别在第四层中的子节点较小值更新dp中
               前三个位置数据为当前最短路径。这样循环层数-1次后最终最短路径就在dp数组的第一个位置（因为每次更新dp的前层数节点数个位置，例如最后一次更新根节点时只有dp【0】被更新了）。
            </p>
            <img src = "./src/images/leetcode120.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/best-time-to-buy-and-sell-stock/submissions/ target="blank" class = "leetcodelink">
                    121. Best Time to Buy and Sell Stock
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>一轮遍历</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               设置两个参数用来track全局最小值和全局最大收益，初始值最小值设置为一个很大的数而最大收益设置为0（根据题目不可能小于0）。之后对数组进行一轮遍历，每看到一个新的数字先判断是否要更新全局最小值，之后判断是否要更新全局最大收益即新数字与全局最小的差值是否大于旧的最大收益。这样一轮结束后
               返回全局最大收益即可。
            </p>
            <img src = "./src/images/leetcode121.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/ target="blank" class = "leetcodelink">
                    122. Best Time to Buy and Sell Stock II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>一轮遍历</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               观察到买股票的时机恰好是当某一天的价格高于前一天时，因为此时如果卖出一定能保证全局利益的最大化。那么我们遍历数组，每次判断当天价格是否比前一天大，如果是就说明该卖出了，结果加上当天和前天差值。价格比前一天小的情况无需处理。
            </p>
            <img src = "./src/images/leetcode122.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/valid-palindrome/ target="blank" class = "leetcodelink">
                    125. Valid Palindrome
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>双指针</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               设置一头一尾两个指针，每次拿到两个指针对应的character后先判断是否有不是数字或者字母的其他字符，因为这种情况我们是不考虑的。这里有个叫Character.isLetterOrDigit()的api非常合适，推荐记住，不然就要用正则。碰到这种情况我们直接将指针
               继续向前或者向后移动。当来到一个两个指针对应character都是char或者int时我们就要判断相等，但不要忘记先调用Character.toLowerCase转换成小写。如果相等继续移动指针，不想等说明不是回文数直接返回false。当两个指针相遇或者重叠时整个循环结束。
            </p>
            <img src = "./src/images/leetcode125.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/word-ladder/ target="blank" class = "leetcodelink">
                    127. Word Ladder
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>BFS</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               要理解这道题首先要明确几个概念。第一个是两个单词是相通的这一说法。当且仅当两个单词只有一个位置上的字母不同时我们称两个单词是相通的。另一点要明确某个单词相通的所有单词中哪些是需要被考虑的，第一是wordlist里一定要有，第二是这个单词之前没有看到过，
               否则就会产生环。题目要求的是最短路径，因此不难想到用bfs的方式来进行搜索，同时记录当前来到了哪一层，这样当找到endword时层数就是最短路径。为了bfs遍历我们需要创建一个queue并将startword放进去开始搜索，其次为了记录哪些wordlist中的词已经遇到过，
               我们需要一个visited set来记录，同时为了判断某一个相通的单词是否在wordlist中，我们需要将wordlist转换成set，最后将level数设置为1。之后开始进行搜索，每次弹出queue顶元素，通过遍历该单词每个位置并替换该位置为a到z中所有字母的方法来找到所有相通的
               单词，首先判断是否找到了endword，其次判断哪些是wordlist中有的并且没遇到过的，加入queue和visited。如果一层都没有找到，level++后开始下一层的搜索，这样一旦找到endword只要返回当前level即可。
            </p>
            <img src = "./src/images/leetcode127.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/sum-root-to-leaf-numbers/ target="blank" class = "leetcodelink">
                    129. Sum Root to Leaf Numbers
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>iteration</li>
                <li>recursion</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               来看递归方法，设置一个辅助方法存贮当前sum，当来到空节点时sum不变所以返回0，每个分支的结束条件为左右子树都为空，此时将当前结果乘10后加上该节点返回。其余情况都是可以继续递归的情况，返回左子树sum+右子树sum即可。
            </p>
            <img src = "./src/images/leetcode129.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/surrounded-regions/ target="blank" class = "leetcodelink">
                    130. Surrounded Regions
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>iteration bfs</li>
                <li>recursion dfs</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              一道基于二维数组的搜索问题，重点看递归dfs和迭代bfs两种方法。先看dfs，我们的目标是要找到所有与border相连的o区域，因此入手点肯定是在边界上寻找o并且寻找所有与这个o相连的o，这些区域肯定是不改变的，其他内部的o我们不必考虑因为最后会变为x。
              确定入手点后我们就可以开始在四条边境寻找o点，每找到一个就从这个点开始dfs搜索。为了防止循环找过的点我们把它标记为*，这样递归的终止条件就是越界或者来到一个不是o的点（可能是*或者x）其他情况递归该点上下左右的位置。这样对四条边界上所有o点
              进行递归后我们就已经将最后确定会是o的点标记成了*，在进行对数组的遍历将*改为o，o改为x即可。接下来看bfs迭代的思路，采用了传统的queue数据结构来跟踪当前的点。这里定义了一个point类用来同时跟踪横纵坐标。还是从边界上所有的o点入手，将所有
              边界o点入queue作为我们的第一层并将该点标记为*，接着在队列不为空时进入bfs循环。每次拿到queue头部的点，寻找它四周满足条件的点（不越界并且是o点），找到后入queue并标记为*。这样循环结束后就达到了和dfs一样的效果，最终o点被标记为了*点，最后进行
              一轮总遍历将*改为o，o改为x即可。
            </p>
            <img src = "./src/images/leetcode130-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode130-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/palindrome-partitioning/ target="blank" class = "leetcodelink">
                    131. Palindrome Partitioning
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>bt</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               经典backtracking题型，设置一个start参数记录当前到达的位置，初始值为0。当start到达length时返回当前数组，其他情况从start开始截取之后所有可能的位置并判断截取的这一段是否是回文数，如果是加入当前数组，更新start值进入下一次递归。在递归结束后
               弹出当前数组最末尾的元素继续回溯查找其他可能性。
            </p>
            <img src = "./src/images/leetcode131.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/clone-graph/ target="blank" class = "leetcodelink">
                    133. Clone Graph
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>iteration bfs</li>
                <li>recursion dfs</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              同样是基于图搜索的问题，看dfs递归和bfs迭代两种方法。观察到我们需要来原图和复制图中来回切换，每次从原图根节点拿到邻居节点，再创建每个邻居节点复制加入原图根节点复制的邻居中。因此我们需要一个hashmap数据结构来将原图节点和复制图对应复制节点存贮或者说关联起来。
              进入递归后判断原图节点是否已经被复制过了，如果是直接返回复制，没有的话创建复制clonenode并将当前节点和clonenode加入hashmap。接下来要做的是复制neighbors，从原图找到每个neighbor并递归地将他们加入clonenode的邻居节点。每一次递归我们创建一个未见过的原图
              节点的复制并将原图节点邻居加入复制节点的邻居，之后递归完成所有的复制。bfs方法还是使用queue来实现类似的过程。首先根节点入队，在queue非空时进入循环，每次拿到一个原图节点并将所有它的未见过的邻居创建复制后邻居入队，之后将每个邻居的复制加入原根节点的复制的邻居。
              其实不论dfs还是bfs都是再重复一个过程，拿到一个原图根节点，创建复制，那我们怎么直到这个复制的邻居是谁呢，还需要从原图根节点的邻居去一个个复制并加入复制根节点的邻居。
            </p>
            <img src = "./src/images/leetcode133-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode133-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/gas-station/ target="blank" class = "leetcodelink">
                    134. Gas Station
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>one pass</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               此题有个很巧妙的一轮遍历，充分利用了只有一个答案的条件。我们从数组头开始设置两个值一个为cur当前油量一个为total记录总油量。每来到一个station就更新cur和total，当cur小于0时说明之前经过的station都不可能是正确答案，因此答案只能是从后面的station开始。此时
               更新cur为0重新开始计数（从一个新的station出发）。但是注意后面的station只是可能成为答案却并不保证。当加的油小于总共需要的油时就没有答案，例如3，3，4 & 3，4，4最后一个4就不是答案。因此我们需要total来判断是否有答案，如果有那么第一个使得cur没有小于0过的station
               就是答案需要的出发点。例如题目的-2，-2，-2，3，3数组，第一个使得cur没有小于0过的station是位置3并且total为0因此有答案并且该答案只能是第一个3，因为此时我们确信第一个3是一个答案并且题目告诉只有一个答案因此只能是第一个另cur不小于0的那个位置。
            </p>
            <img src = "./src/images/leetcode134.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/single-number/ target="blank" class = "leetcodelink">
                    136. Single Number
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>list</li>
                <li>hashmap</li>
                <li>math</li>
                <li>bit wise</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               除了bitwise其他方法都没有一开始尝试的sort + onepass效率高，重点看bit wise。观察到bit wise xor的一个性质是会将相同的两个数字抵消成0，而0和任何其他非零数字xor得到另一个数字。所以正适合这道题的场景，最终所有成对的数字在xor运算中抵消为0，而0和剩下那个单个的目标xor
               得到目标。因此我们直接把所有数字和0进行xor运算即可，十分巧妙高效的方法。
            </p>
            <img src = "./src/images/leetcode136.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>