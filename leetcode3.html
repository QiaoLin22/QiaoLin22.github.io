<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/symmetric-tree/ target="blank" class = "leetcodelink">
                    101. Symmetric Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                先来看递归，判断一棵树是否是对称的相当于判断这棵树在每一层左半部分所有节点是否都在右半部分对于位置存在一个镜像，为了方便判断一对节点是否互为镜像我们做一个辅助方法并将参数设置为两个节点，一开始放入辅助方法的是根节点的两个复制，
                之后递归地判断根节点处的一对镜像位置的值是否相等，一旦出现不想等的情况（包括一个为null）则返回false，所有镜像位置全部相等返回true。迭代的思路利用了老办法用stack数据结构来替代递归所起到的作用，首先将根节点左右两个节点入栈，
                之后在栈非空是进行循环每次拿到一对镜像位置，判断一下时候不想等，相等则继续将这一对镜像位置下一层的两对镜像位置入栈，本质上实现了dfs递归调用，当栈空是所有镜像位置都被判断为相等并返回true。
            </p>
            <img src = "./src/images/leetcode101-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode101-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/binary-tree-level-order-traversal/ target="blank" class = "leetcodelink">
                    102. Binary Tree Level Order Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                还是同样可以用递归和迭代两种方式解决，先来看递归。首先我们发现既然题目要求将同一层的节点放在一起，那我们必然需要在辅助方法中传入一个代表层数的参数来track递归到了哪一层，否则这个信息就无法跟踪。明确了helper method参数后
                我们就要思考如何根据层数信息来构建答案所需的这个二维数组，我们每一个level肯定要有一个对应的arraylist，以后每递归到相同的level就向这个arraylist动态添加数字，所以我们在递归方法中首先要判断有没有当前level所对应的那个arraylist，
                没有就创建出一个空的。具体来说是把level和当前的res。size（）做对比，level大于ressize就要创建一个空的待添加的arraylist。这样就保证了每一层都一定有一个对应的动态数组可以去添加。其他要做的就是通过arraylist的get方法拿到level对应的
                那一层然后添加，接着按照inorder顺序递归traverse树即可，因为题目对每层顺序有要求所以必须是inorder先左支后右支。迭代的思路十分类似，与之前不同的是我们需要使用队列而不是stack，因为我们需要在不破坏当前层顺序的前提下添加下一层。其他要做的
                就是在队列不为空时循环的将队列头部旧层的节点拿出，判断每一个节点左右是否为空并在非空时加入队列，先左后右的顺序不变。要拿到旧层每个节点只需要记录旧层节点总个数然后循环从队列头部poll那么多次即可，在每一层处理完毕后将该层节点数组加入答案。
            </p>
            <img src = "./src/images/leetcode102-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode102-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/ target="blank" class = "leetcodelink">
                    103. Binary Tree Zigzag Level Order Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                与上一题基本雷同，唯一的区别在于奇数层保持顺序而欧树层需要变为逆序，我们只需要一个变量来记录当前是奇数层还是偶数层然后在向答案中添加arraylist前根据这个变量判断是否需要反转数组即可。用boolean或者int均可，这里使用了int。评论区看到一种通过
                构建两个stack或者两个queue并每次修改添加的顺序从左节点右节点到右左来达到反转目的答案，是个有创意的思路。
            </p>
            <img src = "./src/images/leetcode103.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/maximum-depth-of-binary-tree/ target="blank" class = "leetcodelink">
                    104. Maximum Depth of Binary Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                递归比较容易想到，在任意一个节点处的最大深度可以总结为1+它左子树和右子树深度的较大者，当遇到空节点时返回深度0，其余情况递归调用1+max（root.left,root.right）即可。迭代法重用了前两题bfs的思路，用queue数据结构来实现每一层的bfs遍历。观察到
                queue每一轮循环实现了一个旧层节点全部从头部出队列，新层节点全部进队列的过程，这个过程结束时一层dfs即处理完毕也就意味着层数+1.我们可以用一个变量来记录层数的变化，初始值为0，在一轮bfs结束前++即可追踪层数的变化。queue为空也就是循环结束时该变化自然
                等于最大层数。
            </p>
            <img src = "./src/images/leetcode104-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode104-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/ target="blank" class = "leetcodelink">
                    105. Construct Binary Tree from Preorder and Inorder Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               首先观察到要求时按照左中右顺序也就是preorder顺序来构建树，因此我们通过在preorder数组上的递归来构建出树，然而对于每个preorder中的节点，它左子树和右子树所包含的节点存储在inorder数组中，也就是我们需要用preorder的根节点结合inorder的左右子树来递归构建成
               完整的树。为了准确知道每个根节点左右子树包括哪些节点我们就需要四个指针以及一个map来实时跟踪这些信息。map用来存贮inorder数组的位置信息，避免每次都要单独搜索耽误时间（数组中搜索最快也要logn，map则是常数时间），因为每当我们拿到preorder中一个根节点时
               我们都需要知道该节点在inorder中的位置进而拿到左右子树节点信息。四个指针分别记录prestart，preend，instart，inend，prestart和preend初始值为0和preorder的length-1，之后每次递归时根据当前根节点左右子树各包含多少个节点来更新prestart和preend到对应位置。
               例如3左子树有一个节点9，右子树有三个节点，那么下一层递归就会分别被更新为（1，1）和（2，4），instart和inend也根据根节点位置被拆分成左子树和右子树分别包含的节点。可以理解为不停递归从preorder拿到根节点并从inorder拿到该节点左右子树的过程。
            </p>
            <img src = "./src/images/leetcode105.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/ target="blank" class = "leetcodelink">
                    106. Construct Binary Tree from Inorder and Postorder Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               与上一题基本雷同，递归postorder数组，利用inorder来找到左右子树节点数进而在postorder进入下一层递归前更新其左右子树范围。不同的是因为是postorder所以更新时需要按照右子树节点数先更新右子树再更新左子树
            </p>
            <img src = "./src/images/leetcode106.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/binary-tree-level-order-traversal-ii/ target="blank" class = "leetcodelink">
                    107. Binary Tree Level Order Traversal II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               与102题基本雷同，答案直接使用了reverse方法，如果不使用reverse我们也可以每次将新的空list加入arraylist顶部而不是底部然后在添加数字时加在arraylist的size减去level的那一层达到一样的效果。
            </p>
            <img src = "./src/images/leetcode107.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/convert-sorted-array-to-binary-search-tree/ target="blank" class = "leetcodelink">
                    108. Convert Sorted Array to Binary Search Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              答案给出了选取左mid，右mid和randommid三种方法，其实感觉必要性不大，都按照start+（end-start）/2来定位mid即可，设置start，end两个参数初始值设置为数组两边，然后递归地将数组拆分为组成左子树的数组，
              root和组成右子树的数组，当start 大于 end时返回null即达到了叶子节点，其余情况每次将当前mid位置的值作为当前子树的root。递归创建左子树（start，mid-1）和右子树（mid+1，end）然后返回当前root。
            </p>
            <img src = "./src/images/leetcode108.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/convert-sorted-list-to-binary-search-tree/ target="blank" class = "leetcodelink">
                    109. Convert Sorted List to Binary Search Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              和上一题类似的逻辑，不过存贮节点的数据结构从array变为了linkedlist，也就导致我们不能通过index直接拿到mid处的值和左右两个子array了，我们需要用linkedlist的方式来解决这些问题。既然linkedlist不支持随机访问我们就只能从头开始找mid，
              我们怎么知道什么时候到达了mid位置呢，我们可以用双指针，一个快指针一个慢指针，快指针每次前进两个节点（不越界前提）而慢指针只前进一个节点。这样当快指针越界时慢指针就恰好指向mid处所在的位置。那么分离操作如何进行呢，我们有头部指针head，中部
              指针mid，那么mid。next就是后半部分链表，前半部分想要分离出来我们需要slow的前一个位置的指针，我们可以在之前找mid的循环中将这个prev指针一起定位好。设置prev初始值为空指针，每次在slow更新前将prev更新为slow即可。这样我们就拿到了slow结束时前面
              指针的位置，然后将该指针指向null就达到了断开前半部分链表的效果。注意判断prev非空，因为当slow没有移动时（链表长度为1）prev为空，调用pre的next会抛出npe异常。
            </p>
            <img src = "./src/images/leetcode109.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/balanced-binary-tree/ target="blank" class = "leetcodelink">
                    110. Balanced Binary Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>top down递归</li>
                <li>bottom up递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              top down递归比较明显，一个递归方法计算每个节点最大深度，主方法递归判断每个节点是否是平衡的，这样做的缺点是对树进行了重复递归，因为本质上每次调用平衡递归和最大深度递归是在对树的同一部分进行递归，有没有办法在计算最大深度的递归完成时就顺带着比较
              树是否平衡呢？观察到最大深度方法返回一个int而平衡返回一个boolean，这一点影响了我们将两个递归合并，那么我们可不可以用int来代替boolearn而达到同样的效果。我们可以在树平衡时正常递归计算树最大深度，而在不平衡时将节点的最大深度设置为-1。确保只在
              两棵子树都平衡时正常更新为max（leftmax，rightmax），一旦遇到一颗不平衡子树则该父节点最大深度也为-1.这样进行递归时一旦遇到任意一个节点不平衡时都将导致最终结果返回-1，这正是我们想达到的效果。我们只需要在递归返回时判断是否为-1即可判断整个树
              的平衡性。一次递归调用就解决所有问题而不是两个递归嵌套调用，节省了栈资源。
            </p>
            <img src = "./src/images/leetcode110.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/minimum-depth-of-binary-tree/ target="blank" class = "leetcodelink">
                    111. Minimum Depth of Binary Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              唯一一个要注意的点是当一个节点左子树或者右子树为空时，空的那边没有最小深度，不可以作为0去计算。观察到这两种特殊情况后就很简单了，当且仅当有一个子树为空时直接返回另一半子树的最小深度+1即可，空的那一边当作不存在处理。
            </p>
            <img src = "./src/images/leetcode111.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/path-sum/submissions/ target="blank" class = "leetcodelink">
                    112. Path Sum
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              同样可以妙用递归思想，递归树，每遇到一个非空节点就将当前sum值减去该节点值，当来到一个左右都为空且sum已经被减为0的节点时说明找到了这条path返回true，注意一边空一边非空时不返回，寻找还没有结束。其他情况均说明寻找没完成，
              递归寻找左右子树并在任意子树返回true时返回true，所以用｜｜连接。
            </p>
            <img src = "./src/images/leetcode112.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/path-sum/submissions/ target="blank" class = "leetcodelink">
                    113. Path Sum II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              跟上一题思路基本雷同，有几个额外的地方需要注意。第一点是在找到一条路径后想答案添加时需要添加一个新的arraylist并将cur复制进去达到深拷贝的效果。第二点是由于我们在递归中返回到上一层时cur并不会自动pop返回上层时的状态，
              我们需要在一个节点左右子树都寻找完时手动移除cur的最后一个（也就是刚刚探索完毕的那个节点）节点，否则每次cur加入答案时会带着之前寻找到目标之前找过的所有路径。
            </p>
            <img src = "./src/images/leetcode113.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/flatten-binary-tree-to-linked-list/ target="blank" class = "leetcodelink">
                    114. Flatten Binary Tree to Linked List
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              既然是树那么首先考虑递归的思路，先思考每一步要做什么。观察到不管左右支长成什么样子，我们要做的都是把一个根节点左子树剪下来，贴到右子树上，同时为了防止右子树丢失，提前存起来，然后接到之前添加好的新右子树的右子树，这样整个树就变成了一个完整的right skew的树。
              一个特殊情况为当一个根节点有左子树却没有右子树时,我们直接将左子树接到右边即可。当两个子树都非空时具体拼接方法如下，首先剪下左右子树并存贮，然后左子树变为空，右子树首先接上原左子树，接着为了找到新右子树的尾巴，用一个loop来寻找，找到末尾后接上原右子树。之后
              递归调用右子树即可。
            </p>
            <img src = "./src/images/leetcode114.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/populating-next-right-pointers-in-each-node/ target="blank" class = "leetcodelink">
                    116. Populating Next Right Pointers in Each Node
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>迭代on空间，queue</li>
                <li>迭代o1，no extra space</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              第一种方法沿用了传统的迭代level order traverse也就是使用queue的数据结构每次拿到一整层的node再依次连接起来，比较trivial不做讨论。第二种方法达到了no extra space并且方法十分的巧妙，重点研究一下。第二种思路的核心思想在于我们可以利用某一层已经连接好next
              的node在直接构建出下一层node所有next所需要的连接，观察到根节点恰好就是那个已经连接好next的层，所以我们可以顺次构建出第二层，在用同样逻辑从第二层构建第三层以此类推。那么具体每层如何构建出下一层呢，初始条件只有一个上一层第一个node，但是该node之后所有next已经
              被连接好了，相当于一个linkedlist，我们可以通过next来直接遍历这一层。再观察发现下一层的连接有两种情况，同parent两个节点连接以及来自两个上层相邻parent左节点和右节点连接，不论那种情况都可以通过上层直接连接。假设我们上层负责遍历的节点叫head，那么同parent下层
              节点可以直接用head.left.next = head.right连接。不同parent无外乎就是用head和head。next一起构建，也就是 head.right.next = head.next.left（注意判断head next非空）这样下层就连接完毕。同时我们从开始就维护一个每一层最左边的节点，leftmost作为每层
              遍历的起点，在一层连接完毕后直接更新leftmost为leftmost。left即可，因为这是一颗完整的二叉树所以leftmost。left不可能为空。这样从根节点开始每一层从leftmost（根节点leftmost就是自己）开始遍历构建出下层next连接然后更新leftmost到left也就是下层第一个节点就可以完成整棵树的所有连接。
            </p>
            <img src = "./src/images/leetcode116.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/ target="blank" class = "leetcodelink">
                    117. Populating Next Right Pointers in Each Node II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>迭代on空间，queue</li>
                <li>迭代o1，no extra space</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              答案第二种思路写的相当繁琐，推荐一种网上看到的递归思路。首先沿用上一题思路，通过上一层next连接来构建下层next连接。对于每一个点它的左子树可能为空，右子树也可能为空，我们就要分类讨论，首先判断左子树是否为空，非空就简单了，直接root.left.next = root.right。
              如果左边根本没有我们就不需要处理左分支了，递归到下一层即可。如果左边非空我们就要根据右子树情况判断当前最右边节点是rootleft还是rootright。之后在上层next中寻找rightmost的next节点，当上层next节点left非空时就连接到该节点，上层next的right非空时就连接到
              right，找到后理解结束循环。这样每一次递归我们都在尝试将该节点左右节点中非空的那个连接到下一个正确的位置。如此递归左右子树即可。
            </p>
            <img src = "./src/images/leetcode117.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/pascals-triangle/ target="blank" class = "leetcodelink">
                    118. Pascal's Triangle
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
              从这个金字塔的形状很容易想到dp也就是从上一层构建出下一层，那么我们要先把第一层写好并将第一层当作dp的初始值，这样从第二层开始所有层都可以从上一层顺次得出。设置一个当前层数level为2，当level小于等于numrows时进入while循环，每次拿到上一层两个值并相加并在头尾
              添上1就等到了当前需要的这一层，将该层加入答案。这样循环结束时所有numrows层就都构建完毕。
            </p>
            <img src = "./src/images/leetcode118.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/pascals-triangle-ii/ target="blank" class = "leetcodelink">
                    119. Pascal's Triangle II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
                <li>dp memory efficient</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               这次我们只需要拿到最后一层而非所有的层，依然可以沿用上一题的思路从n层构建出n+1层，但这道题重点是如何节省空间，当然可以先构建整个金字塔（上题）然后只返回最底层，但是对空间造成了极大的浪费。先来看第一种较容易想到的dp，该思路从始至终只构建了两个arraylist res和pre，一个代表
               上层一个代表下层，res初始值只有一个1而pre为空，然后每次先用res构建出下一层，使res指向下一层，然后pre指向原res就完成了从n-1，n层到n，n+1层的转移，这样循环rowindex次res就指向了最底层。再看第二种dp思路，该思路从始至终只构建了一个arraylist，通过不断修改该arraylist直到
               拿到最底层，仅仅使用了必须的空间没有一点额外空间浪费。具体实现如下，初始arraylist大小直接设置为最终所需要的rowindex+1，并先添加一个1代表第一层。之后层从上层尾部开始逆向将上层j和j-1位置两两相加保留头部也就是1不变，最后在尾部添加1完成新层的构建。这样rowindex轮结束arraylist
               正是我们要的最底层。概括下就是方法1每次将旧arraylist构建并放到一个全新arraylist中，然后抛弃旧的。第二种方法是直接在原地将旧的改成新的而没有复制操作。
            </p>
            <img src = "./src/images/leetcode119-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode119-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/triangle/ target="blank" class = "leetcodelink">
                    120. Triangle
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>bottom up dp</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
               一开始尝试top down dp但是失败了，因为当树中有负数时我们无法简单的通过当前节点和左右中最小的那一边来判断出正确路径，但是bottom up则不然，top down中当前最小路径不一定和下一层中最小的相连接，bottom up中从底下向上找时由于我们已经在底层穷尽了所有情况，所以只需要放心的将当前层中所有
               路径加进来即可。我们可以将dp数组初始值设置为最底层，因为此时底层自己就是到自己的的最短路径，没向上拿到一层，就将dp数组的前当前层个数个数据更新，更新方法为当前节点值加上上一层左右子节点中小的那一个。例如从第四层更新第三层时，根据第三层三个节点和它们分别在第四层中的子节点较小值更新dp中
               前三个位置数据为当前最短路径。这样循环层数-1次后最终最短路径就在dp数组的第一个位置（因为每次更新dp的前层数节点数个位置，例如最后一次更新根节点时只有dp【0】被更新了）。
            </p>
            <img src = "./src/images/leetcode120.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>