<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/symmetric-tree/ target="blank" class = "leetcodelink">
                    101. Symmetric Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                先来看递归，判断一棵树是否是对称的相当于判断这棵树在每一层左半部分所有节点是否都在右半部分对于位置存在一个镜像，为了方便判断一对节点是否互为镜像我们做一个辅助方法并将参数设置为两个节点，一开始放入辅助方法的是根节点的两个复制，
                之后递归地判断根节点处的一对镜像位置的值是否相等，一旦出现不想等的情况（包括一个为null）则返回false，所有镜像位置全部相等返回true。迭代的思路利用了老办法用stack数据结构来替代递归所起到的作用，首先将根节点左右两个节点入栈，
                之后在栈非空是进行循环每次拿到一对镜像位置，判断一下时候不想等，相等则继续将这一对镜像位置下一层的两对镜像位置入栈，本质上实现了dfs递归调用，当栈空是所有镜像位置都被判断为相等并返回true。
            </p>
            <img src = "./src/images/leetcode101-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode101-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/binary-tree-level-order-traversal/ target="blank" class = "leetcodelink">
                    102. Binary Tree Level Order Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>迭代</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                还是同样可以用递归和迭代两种方式解决，先来看递归。首先我们发现既然题目要求将同一层的节点放在一起，那我们必然需要在辅助方法中传入一个代表层数的参数来track递归到了哪一层，否则这个信息就无法跟踪。明确了helper method参数后
                我们就要思考如何根据层数信息来构建答案所需的这个二维数组，我们每一个level肯定要有一个对应的arraylist，以后每递归到相同的level就向这个arraylist动态添加数字，所以我们在递归方法中首先要判断有没有当前level所对应的那个arraylist，
                没有就创建出一个空的。具体来说是把level和当前的res。size（）做对比，level大于ressize就要创建一个空的待添加的arraylist。这样就保证了每一层都一定有一个对应的动态数组可以去添加。其他要做的就是通过arraylist的get方法拿到level对应的
                那一层然后添加，接着按照inorder顺序递归traverse树即可，因为题目对每层顺序有要求所以必须是inorder先左支后右支。迭代的思路十分类似，与之前不同的是我们需要使用队列而不是stack，因为我们需要在不破坏当前层顺序的前提下添加下一层。其他要做的
                就是在队列不为空时循环的将队列头部旧层的节点拿出，判断每一个节点左右是否为空并在非空时加入队列，先左后右的顺序不变。要拿到旧层每个节点只需要记录旧层节点总个数然后循环从队列头部poll那么多次即可，在每一层处理完毕后将该层节点数组加入答案。
            </p>
            <img src = "./src/images/leetcode102-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode102-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
    </main>
</body>
</html>