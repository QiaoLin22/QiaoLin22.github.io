<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/maximum-subarray/ target="blank" class = "leetcodelink">
                    53. Maximum Subarray
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>分治</li>
                <li>贪心</li>
                <li>动态规划</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                分治是一种可行的思路，不断将原始数组拆分成左半边右半边和跨越两边的总数组，迭代地寻找三个数组中最大的，最后返回的数字就是全局最大的答案，此方法时间复杂度不算最优，重点分析下后两种方法。
                贪婪的核心思想是每一步去局部最优解进而在最后得到全局最优解。这里储存两个变量，一个当前最大连续和，一个全局最大和，接着遍历数组，每次顺次更新这两个变量最后得到的全局最大和就是答案。动态规划
                在这里和贪心没有太大区别，核心思路是一致的。贪婪每次将当前最大和更新为当前看到的数字和此数字和当前局部最大和之和两者中的较大者（max（nums【i】，nums【i】+curr）），相当于用简单的取max
                操作省去了一个当前curr是否小于0的判断，亦或是第三种方法中nums【i-1】是否大于0的判断。另一个区别是第三种没有使用变量存贮当前最大和而是将局部最大和随着nums的遍历一起更新到nums【i】中了。
                从另一个角度考虑，当前curr小于0的时候只能将curr更新成当前看到的数字，因为无论这个数字是正还是负，这个数字都大于它自己与curr之和。当curr大于0时，统统加上当前看到的数字即可，即使这个数字
                是负数也不影响全局最大和的正确性。例如curr为2，看到一个-3，将curr更新为-1看似小了实则没有影响因为全局max已经看到过2了，只需要保证增大时能够正确更新即可。推荐如下写法，清晰易懂，这种写法和第二三种思路完全是等价的。
            </p>
            <img src = "./src/images/leetcode53.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/spiral-matrix/ target="blank" class = "leetcodelink">
                    54. Spiral Matrix
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>模拟</li>
                <li>按照螺旋层添加</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                认为第二种思路更自然，重点分析下。首先通过观察发现这个题可以用一个分成四部分的大循环完成遍历，这四部分分别为，最上面一行从左至右添加，最右边一列从上到下添加，最下边一行从右至左添加，
                以及最左边一行从下至上添加。并且要注意不重复和顺序的问题，自然联想到可以用四个指针记录这上下左右四个界的变动情况来达到这个目的。实现起来也不太难，每种情况都是用一个小的循环完成即可。
                有两点需要特别注意，第一点是在上下界或者左右界相等（相遇）时不要终止循环，否则会漏掉中间的一层。第二点是最上面一层左到右和最右边一层上到下两个小循环完成之后，其余两个小循环在进入
                前可能已经达到了终止条件，需要再次判断下是否应当立即结束循环。例如1-9的数组转完一圈之后上下左右都是1，进入第二轮大循环添加5，此时本来应当结束了，可是此时左右都为1，因此继续执行
                最下面一行从右向左添加，5就被加了两次。疏忽这一点会导致最后一次左到右添加的数又被从右向左添加一次（也可能是下到上重复）。解决方法简单，后两个小循环进入前判断下，如果出现左大于右或者
                上大于下立即结束即可。
            </p>
            <img src = "./src/images/leetcode54.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>