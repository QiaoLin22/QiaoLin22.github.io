<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
          <li class = "link"><a href = "./leetcode4.html">4</a></li>
          <li class = "link"><a href = "./leetcode5.html">5</a></li>
          <li class = "link"><a href = "./leetcode6.html">6</a></li>
          <li class = "link"><a href = "./leetcode7.html">7</a></li>
          <li class = "link"><a href = "./leetcode8.html">8</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/maximum-subarray/ target="blank" class = "leetcodelink">
                    53. Maximum Subarray
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>分治</li>
                <li>贪心</li>
                <li>动态规划</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                分治是一种可行的思路，不断将原始数组拆分成左半边右半边和跨越两边的总数组，递归地寻找三个数组中最大的，最后返回的数字就是全局最大的答案，此方法时间复杂度不算最优，重点分析下后两种方法。
                贪婪的核心思想是每一步去局部最优解进而在最后得到全局最优解。这里储存两个变量，一个当前最大连续和，一个全局最大和，接着遍历数组，每次顺次更新这两个变量最后得到的全局最大和就是答案。动态规划
                在这里和贪心没有太大区别，核心思路是一致的。贪婪每次将当前最大和更新为当前看到的数字和此数字和当前局部最大和之和两者中的较大者（max（nums【i】，nums【i】+curr）），相当于用简单的取max
                操作省去了一个当前curr是否小于0的判断，亦或是第三种方法中nums【i-1】是否大于0的判断。另一个区别是第三种没有使用变量存贮当前最大和而是将局部最大和随着nums的遍历一起更新到nums【i】中了。
                从另一个角度考虑，当前curr小于0的时候只能将curr更新成当前看到的数字，因为无论这个数字是正还是负，这个数字都大于它自己与curr之和。当curr大于0时，统统加上当前看到的数字即可，即使这个数字
                是负数也不影响全局最大和的正确性。例如curr为2，看到一个-3，将curr更新为-1看似小了实则没有影响因为全局max已经看到过2了，只需要保证增大时能够正确更新即可。推荐如下写法，清晰易懂，这种写法和第二三种思路完全是等价的。
            </p>
            <img src = "./src/images/leetcode53.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/spiral-matrix/ target="blank" class = "leetcodelink">
                    54. Spiral Matrix
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>模拟</li>
                <li>按照螺旋层添加</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                认为第二种思路更自然，重点分析下。首先通过观察发现这个题可以用一个分成四部分的大循环完成遍历，这四部分分别为，最上面一行从左至右添加，最右边一列从上到下添加，最下边一行从右至左添加，
                以及最左边一行从下至上添加。并且要注意不重复和顺序的问题，自然联想到可以用四个指针记录这上下左右四个界的变动情况来达到这个目的。实现起来也不太难，每种情况都是用一个小的循环完成即可。
                有两点需要特别注意，第一点是在上下界或者左右界相等（相遇）时不要终止循环，否则会漏掉中间的一层。第二点是最上面一层左到右和最右边一层上到下两个小循环完成之后，其余两个小循环在进入
                前可能已经达到了终止条件，需要再次判断下是否应当立即结束循环。例如1-9的数组转完一圈之后上下左右都是1，进入第二轮大循环添加5，此时本来应当结束了，可是此时左右都为1，因此继续执行
                最下面一行从右向左添加，5就被加了两次。疏忽这一点会导致最后一次左到右添加的数又被从右向左添加一次（也可能是下到上重复）。解决方法简单，后两个小循环进入前判断下，如果出现左大于右或者
                上大于下立即结束即可。
            </p>
            <img src = "./src/images/leetcode54.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/jump-game/ target="blank" class = "leetcodelink">
                    55. Jump Game
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>回溯</li>
                <li>自顶向下动态规划</li>
                <li>自底向上动态规划</li>
                <li>贪婪</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                动态规划比较容易想到，但在这里不是最优解，因为我们只要知道能不能跳到最后，不是所有能跳过去的路径，因此bt在这里浪费时间了。再来看动态规划，这里dp结合了缓存的思想来尽可能为bt加速，核心原理是普通bt
                进行了很多无谓的比较，不如曾经到达过的某些位置明明已知无法到达重点，却在回溯过程中被重复考虑可能性，为此可以用一张表来记录访问过的位置的可达性，如果回溯到某个已知不可达的位置直接跳过，这就是自顶向下
                dp的核心思路。自底向上dp的核心思想在于我们直接不需要回溯这个框架了，充分利用了此类问题的方向行。如果从右向左找，我们每次一定可以确实地把一个位置标记为可达或者不可达，因为不可能重新回到右边，所以回溯也就没有
                意义了。最后一个位置一开始就是可达自己的，向前遍历时每次判断一个位置在它可触及的范围内是否有一个可达终点的位置，有说明他自身也是可达终点的，如此类推最后得到从起点是否可达终点。贪婪则是直接连记录某个位置
                是否可达都放弃了，充分利用了此题只需找出任意一种可能性的特点。从前向后或者反着都可以，向前核心思想是找出从当前可以向后延伸到的最远位置，在这些位置里找出能延伸的更远的位置，以此类推逐步向后推进最后判断是否
                达到了终点。反之亦然，每次向前找到可达终点的位置，逐步缩小末尾位置，如果最后末尾达到0就说明起点可达终点。可以想像起点和终点一个往后够，一个往前够，如果最终能达到彼此就说明可达。
            </p>
            <img src = "./src/images/leetcode55.png" height = 500px, width = 1200px alt = "leetcode"/>
            <hr>
        </section>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/merge-intervals/ target="blank" class = "leetcodelink">
                    56. Merge Intervals
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>暴力解法</li>
                <li>排序后一轮循环</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                主要难点在于如何排序，推荐评论区看到的一种java8 lambda表达式一行的写法，答案则是创建了一个继承了comparator接口的类并重写了compare方法，比较繁琐。按照数组首个数字排好序后就比较简单了，为了不修改原有数组创建一个新的
                空的list和一个指针newinterval，newinterval初始值为第一个数组直接加入res（在循环中加入也可以），每次遍历跟当前数组做比较。如果有overlap的情况，判断是否需要变更newinterval。注意不是所有overlap的情况都需要变更指针，例如1，4和2，3对比，虽然重合
                但是无需更新指针，为了方便可以将newinterval的第二个位置直接更新为指针第二个位置和当前数组第二个位置的最大者。这样1，4碰到2，3依然保持1，4，而1，3碰到2，6就更新为1，6保证了正确性。如果没有overlap的现象发生则把指针
                指向的数组添加进答案就向后移动指针，即把当前数组复制给指针，然后进入下一次遍历。注意顺序，否则会丢失指针原有的引用。最后将list of array转换为2d array返回即可。
            </p>
            <img src = "./src/images/leetcode56.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/length-of-last-word/ target="blank" class = "leetcodelink">
                    58. Length of Last Word
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>操作下标</li>
                <li>一轮循环</li>
                <li>内置函数</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                很容易想到内置函数indexof，但是字符串结尾有一个或者多个0时会干扰到indexof的判断，提前将结尾的0截掉即可。不使用内置函数也可以用循环找出最后一个非空格数字的下标，并从那里向前找到第一个空格为止计算长度。
                第二种思路将第一种中的两个循环合并成一个循环，从结尾向前找当找到一个非空格时记录这一串字符长度，当找到一个空格并且已经记录过长度时退出循环返回这个长度，其余情况即是仍然在遍历尾部的空格中。
            </p>
            <img src = "./src/images/leetcode58.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/spiral-matrix-ii/ target="blank" class = "leetcodelink">
                    59. Spiral Matrix II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>无</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                和54题思路基本雷同。提前构建空的二维数组和四个指针，最上面一行，最下面一行，最左边一列和最右边一列，并在主螺旋循环中的每个边循环完成后更新对应的值，这样即可做到不充不漏的遍历整个矩阵。依然是注意最下面一行右到左
                循环和最左边一列下到上循环进入前可能已经达到终止条件，需要提前判断避免重复。其余就是每次边循环放入一个自增的变量即可。
            </p>
            <img src = "./src/images/leetcode59.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/permutation-sequence/ target="blank" class = "leetcodelink">
                    60. Permutation Sequence
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>映射法（找规律）</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                答案的思路是根据阶乘的性质将每个排序映射为一个基于阶乘系统的表示法，评论区看到一种核心思路一致但更简洁自然的想法。首先我们为了得到目标排序，需要知道目标每一位上对应的是哪个数字，这是有规律可循的，规律的提供者正是阶乘的性质。
                注意到从左至右以每个数字开头的一组排序个数为（n-1）的阶乘个，没向后移动一位，以相同数字开头的排序组缩小为上一个数减1的阶乘个，一次类推。比如1，2，3，4的排序，以1为开头组的排序共有1，2，3，4；1，2，4，3；1，3，2，4；1，3，4，2；
                1，4，2，3；1，4，3，2六个，这一大组又以第二个数子分成三个小组，比如1，2开头的共有两个，1，3开头两个以此类推。利用排序阶乘这一性质我们可以定位到k个排序的每个位置分别对应哪个数字。注意由于题目中k是从1开始，所以需要减去1才能和
                位置下标完美对应。先看第一位，我们知道所有排序按照第一位数字分成了（n-1）阶乘个排序的组，那么自然想到用k/（n-1）！就可得到第一位数字对应的下标（所在第几组）。例如想找第八个排序的第一位，7/6=1，那么第一位就是数组下标1的数字也就是2。
                接着更新k位k%（n-1）！，（n-1）！更新为（n-2）！就进入了定位2开头所在的组的第二个位置数字的问题。取模运算得到此时下一层中每组排序个数，更新阶乘只需要除以当前剩余未使用的数字个数即可。用链表存贮初始数组，每定位一个位置数字就将该数字
                移除链表，保持相对位置正确性。当所有数字都没使用后结束循环，此时已经找到了目标位置的完整字符串。此题十分巧妙的利用了排序中阶乘的性质。

            </p>
            <img src = "./src/images/leetcode60.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/rotate-list/ target="blank" class = "leetcodelink">
                    61. Rotate List
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>转接链表</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                思路还是很清晰的，首先为了正确找到需要转接的位置，需要计算链表的长度，然后用k对长度取模即可。其次就是注意两个指针的位置，一次从头开始（最好不移动head，创建一个新指针），移动到
                转接点并构建一个子链表，一个从转接点开始移动到末尾，然后将末尾node连接到头部指针即可。注意转接点位置需要单独记录否则会在遍历到末尾的过程中丢失。链表为空的情况需要特殊处理。
            </p>
            <img src = "./src/images/leetcode61.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/unique-paths/ target="blank" class = "leetcodelink">
                    62. Unique Paths
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                经典dp问题，创建一个二维数组，初始化第一行和第一列为1（到达这些位置只有一种走法），然后遍历数组，剩下每个位置的走法数量为上面位置和左面位置走法数量之和。遍历结束后最右下角的
                走法数量就是总的走法。答案将整个数组一起初始化为一个充满1的数组，调用了arrays api的fill方法，可以节省一些时间。
            </p>
            <img src = "./src/images/leetcode62.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/unique-paths-ii/ target="blank" class = "leetcodelink">
                    63. Unique Paths II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                上一道题的变形，障碍物的位置自然为0，那么障碍物会对其他位置的路径有什么影响呢。注意到如果障碍物不在第一行或者第一列上的时候对它们右边和下面的路径是没有影响的，因为右边和下边位置依然遵循
                左边路径+上边路径的法则。只有在第一行或者第一列的时候障碍会导致所有右边或者下边路径均为0。所以这两种情况时我们将法则稍作改变即可。原本障碍物位置路径为0这一点不变，这些位置的路径是不可被改变的。
                我们可以将目标矩阵初始化时障碍物位置为0，其他位置1，遍历矩阵时跳过障碍物位置保持0，不在第一行或者第一列时保持左+上法则。在第一行列的时候将路径数直接从左边或者上边继承，这样没碰到障碍时
                保持1的状态，碰到后所有右边或者下边位置都将为0。注意0，0这个点要特殊处理，否则因为该点不存在左和上位置会抛出indexoutofbound错误。
            </p>
            <img src = "./src/images/leetcode63.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/minimum-path-sum/ target="blank" class = "leetcodelink">
                    64. Minimum Path Sum
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
                <li>原地dp</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                因为可以在原理更改数组得到答案所以没必要特意构建新的数组浪费空间。基本思路很简单，遍历数组，左上角保持不变，第一行和第一列计算方式为自己加左边或者上边。其余位置
                计算方式为取自己加左边和自己加上面二者中较小值。如此这般遍历完成后最短路径就在右下角位置。经典dp题型。
            </p>
            <img src = "./src/images/leetcode64.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/plus-one/ target="blank" class = "leetcodelink">
                    66. Plus One
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>遍历进位叠加法</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                要注意没法先转换成int加1在转换为数组返回，因为会超出interger上限即使用long速度也很慢。遍历数组的思路锁定在如何处理进位的问题，稍作观察能发现当且仅当某位置为9时才会发生进位，
                就利用这一点来处理进位的问题。进一步说，每次遍历有两种情况，不是9，当前位置加1，结束。是9，当前位置变为0，进位变为1并叠加到下一轮循环中。有了这个框架问题基本解决了，但还可以
                稍作优化。观察到没有进位发生时我们不需要创建新的数组，在原有基础上改即可。有进位发生但是数组总长度不变时也一样。只有一种情况需要创建新数组即最高位发生了进位，例如99变成了100。
                这种情况发生时不要急着将老数组搬运到新数组对应位置，观察发现该情况原数组每个位置全为0！因此只需要把新数组首个位置变为1，其他保留初始化默认值0即可。保留了自己的带有carry的写法，
                认为这种更容易理解可读性高。
            </p>
            <img src = "./src/images/leetcode66.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/add-binary/ target="blank" class = "leetcodelink">
                    67. Add Binary
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>按位置计算</li>
                <li>位运算</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                按位置运算是自然的想法，我使用了先将对应位置转为int在进行加法运算更新答案和carry的方法，答案一直接通过某一位置上char 1出现的次数更新carry和答案，两者均可。答案一判断1出现的次数，一次则carry
                为1，0次carry为0，2次carry为2，然后根据carry将答案更新carry%2，然后更新两个指针（注意预防空指针），carry更新为carry/2，进入下一轮循环。注意循环结束后carry仍为1要在结尾添加一个进位得来的1，
                最后将答案反转即可得到需要的结果。方法二使用了纯粹的位运算，用biginteger表示a和b，观察到，加法操作在不考虑进位的情况下等价于xor位运算操作，而进位的问题又完美等价于and后左移一位的位运算。例如
                11+1的问题，在不考虑进位下进行与或运算得到10，and左移运算计算进位得到010，恰好表示了进位的位置，进入下一轮，10和010与或运算得到00，进位得到100，再进行与或运算得到结果100，此时进位为0循环终止，
                返回100即为答案。利用了在不使用加法运算时，加法可以用与或运算替代，进位可以用and后左移替代的特点，一个while循环解决了问题。
            </p>
            <img src = "./src/images/leetcode67.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/sqrtx/ target="blank" class = "leetcodelink">
                    69. Sqrt(x)
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>二分查找</li>
                <li>递归+位运算</li>
                <li>newton method</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                先看二分查找，通过观察发现答案被锁定在一定的区间内，即从2到x/2，只有两个例外即0和1，所以需要特殊处理。锁定区间后问题就被转换成了一个二分查找问题，我们可以通过比较指针（left + (right-left)/2）位置数字的平方和x大小关系来判断
                如何移动指针，找到一致的就返回指针位置，否则循环结束后返回右指针。再看方法二，关键在于如何通过递归来缩小范围，观察发现sqrt（n）和sqrt（n/4）之间存在某种联系。sqrt（n）总是可以表示成二倍的sqrt（n/4），我们将它命名为left，因为
                left只是下限，或者left+1。具体是left还是left+1取决于left+1的平方和x的大小关系，例如16对应left4即为正确答案，而15的left则只为2，2+1才能得到3，只有当right平方大于x的时候返回left，其余情况返回right即可保证总是得到正确答案。
                第三种newton 法则就是直接套公式，前提是了解公式，属于numerical analysis范畴。
            </p>
            <img src = "./src/images/leetcode69-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode69-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/climbing-stairs/ target="blank" class = "leetcodelink">
                    70. Climbing Stairs
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>暴力</li>
                <li>缓存迭代</li>
                <li>动态规划</li>
                <li>斐波那契</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                方法二三四本质上都是都是一个自底向上的迭代方法。注意此题自顶向下迭代会超时，自底向上其实应用的就是缓存的思路，即重复利用之前计算过的值。方法二预先创建了一个数组并将
                每一步计算值存入该数组并在下一次迭代时拿出来使用，但造成了无意义的栈资源浪费。方法三和二没有本质的区别只是动态的向预先创建的数组里添加计算过的值避免了栈资源开销，但
                创建数组的额外空间造成了浪费。方法四没有额外空间开销从始至终只有两个int值，通过在循环中更新这两个值达到了和动态规划一样的效果。下图保留了将n为1和2都作为base case的写法。
            </p>
            <img src = "./src/images/leetcode70.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/simplify-path/ target="blank" class = "leetcodelink">
                    71. Simplify Path
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>stack</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                此题理解了题意后还是比较明显的。要处理任何一个路径无疑就是三种情况，根本不需要处理的路径（。或者空），需要回退的“。。”以及需要添加到路径的其他情况。只要将目标字符串按照“/”分开就可以
                运用stack的数据结构一遍遍历完成处理，碰到不需要处理的字符跳过，碰到回退的情况末尾出栈（注意判断非空），其他需要添加的字符直接入栈。最后将栈中处理好的路径重新用“/”连接好即可。注意
                初始字符串为空和栈为空时需要特殊处理，栈为空时因为跳过循环缺少了开头的“/”，补全即可。
            </p>
            <img src = "./src/images/leetcode71.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/set-matrix-zeroes/ target="blank" class = "leetcodelink">
                    73. Set Matrix Zeroes
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>有额外空间</li>
                <li>无额外空间暴力解法</li>
                <li>无额外空间高效</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                有额外空间的思路很容易想到，用两个hashset记录出现过0的行列，在第二轮循环里更新这些行列的值为0。方法二在第一轮遍历找到0时就强行把那一行和那一列的所有值更新为0，次做法效率很低，因为很多
                本来已经是0的位置被反复刷新为0造成时间浪费。方法三发现一种方法，即采用第一行和第一列在记录整个矩阵的状态，如果某一行出现了0，该行的第一个位置就被标记0，列同理。这样有一个问题，就是第一行
                和第一列本身该如何处理，如果采用相同做法就会导致第一行的0错误地覆盖了第一列的值。例如第一列全部为1，第一行第二个位置出现了0，此时该0会将（0，0）位置标记为0，那么
                在之后根据（0，0）构建第一列时会错误地认为第一列出现过0而全部更新为0，其实第一列并未出现过0。要解决这个问题只能将第一行或者第一列中的某一个单独拿出来做处理。答案三是将第一列单独做处理，
                在第一轮遍历时单独记录第一列有没有出现过0（遍历时直接忽略第一列），第一行可以做正常处理。可以理解为将第一列第一个位置（0，0）从整个矩阵分离单做记录，其余位置采用行列首位置记录法。第二轮统一
                更新0时第一行和第一列也要单拿出来更新，避免覆盖问题。此时行第一个位置只要是0就全部更新为0，列则要看之前记录的结果，即当且仅当第一列上确实出现过一个0才全部更新为0。
            </p>
            <img src = "./src/images/leetcode73.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/search-a-2d-matrix/ target="blank" class = "leetcodelink">
                    74. Search a 2D Matrix
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>二分查找</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                此题思路很明确是二分查找，因为整个数组都是有序的，但关键一点是能否观察到整个二维数组可以转换成一个一维数组，如果作为二维数组处理就要先确定行再确定列，第一次用这种方法通过了但是速度较慢。观察到
                初始数组行列都有序，于是可以根据行列坐标将二维数组直接转换成一维处理。具体做法自然是start设置为0，end设置为最后一位长度也就是m*n-1，开始二分查找后每次设置index为start+（end-start）/2 每次将target和
                matrix【index/n】【index%n】，也就是一维映射到二维对应位置拿到该位置的值做对比，其余操作和普通二分查找一致。此方法充分利用了二维数组行列均有序的性质，将二维坐标映射到了一维坐标。
            </p>
            <img src = "./src/images/leetcode74.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/sort-colors/ target="blank" class = "leetcodelink">
                    75. Sort Colors
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>一遍循环常数空间</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                既然要求常数空间和一遍循环，很自然想到交换。一开始尝试了首尾两个指针互相交换，然而发现无法处理都是1时改如何移动指针，既然两个指针没法处理1的问题，一个指针能不能解决呢，答案是能。一个指针时只有三种情况，即0，1，2，
                0时自然是换到开头，二时换到结尾，1时直接跳过即可无需处理，大大简化了双指针时所需处理的可能性。接着要注意一点是指针碰到0时交换后同时更新指针和开头位置，因为此时数组截止到curr为止是有序的，而指针碰到2时交换后则不一定保证有序性，
                例如00120，进行到start1，curr2，结尾0时，curr和结尾交换得到00102，截止到curr的有序性被破坏了，此时只能更新end--而不能更新curr++，因为此时curr还未被确定，需要继续和start做比较。此处可以类比选择排序的过程。其余就是交换时可以直接让开头或者结尾的值覆盖
                curr位置，然后把curr位置原先的0或者2赋值给开头或者结尾，不需要额外创建temp来存储curr原来的值，因为我们本来就知道这个值。
            </p>
            <img src = "./src/images/leetcode75.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/combinations/ target="blank" class = "leetcodelink">
                    77. Combinations
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>回溯</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                经典的回溯题型，创建一个index来记录当前添加list首个数字，当前list中填满k个数字是向答案中添加当前list，否则继续向后循环寻找其他可能性并递归调用回溯方法。可以理解为for循环遍历了1⃣️各个数子开头的情况，
                每种数字开头的具体情况由递归方法寻找到所有可能组合。index也可以理解为当前list中以添加数字的个数。
            </p>
            <img src = "./src/images/leetcode77.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/subsets/ target="blank" class = "leetcodelink">
                    78. Subsets
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>逐层叠加</li>
                <li>回溯</li>
                <li>Lexicographic (Binary Sorted) Subsets</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                第一种方法更像是dp或者bfs，level by level的处理每一个数字。初始答案为空，每次拿到下一个需要考虑的数字，把这个数字添加到之前答案里的每一个组合，并把得到的每一个新组合添加回答案中。例如考虑123，先拿到1，得到新的组合
                为1，加入答案，此时答案为空和1，再拿到2，把2和目前答案中已有的所有组合拼接，得到新组合，2，1和2，加入答案得到空，1，2，1&2，最后拿3和当前答案组拼接，得到新组合3，1&3，2&3，1&2&3就是所有可能的组合。这种每次
                处理一个并按顺序处理掉所有可能性并逐步完善答案的思想和dp非常契合。答案二bt可以直接借鉴77题，只是为每个长度做了一轮遍历。第三种方法认为每个subset都有一个唯一的二进制字符串与之对应，0代表对应位置无数字，1代表有。
                例如123对应为111，13对应为101，空集对应000。按照这个思路先生成所有二进制字符串，在将它们转换为对应的subset添加进答案。图为方法一和bt方法。
            </p>
            <img src = "./src/images/leetcode78-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode78-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/word-search/ target="blank" class = "leetcodelink">
                    79. Word Search
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>回溯</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                此题是一道非常精妙的回溯算法题，没有用之前常见的array或者hashset等数据结构，而是在二维矩阵中进行寻找和回溯。首先明确回溯方法里的参数，需要一个index来记录匹配的个数，两个位置坐标分别表示
                行和列，还有原先的两个参数矩阵和待搜索string。接着明确主思路，为了遍历所有可能性，我们需要在原矩阵的每个位置都进行搜索，如果找到了下一个匹配，就递归搜索它的上下左右四个位置。对于每一个位置
                有五种情况可以立即返回false，即越界（row过大过小，col过大过小）以及不匹配。为了防止重复搜索之前搜索过的路径，我们还需要一个方法来记录某次搜索的某个位置是否已经匹配过了。方法很简单，当匹配到
                一个字符时，将对应位置上的原有字符覆盖为一个其他的值，在回溯后将该位置恢复为之前的值即可，相当于将来的时候找过的路径恢复成原有状态，为遍历下一个位置作准备。如果在单次回溯中不标记已经匹配过的路径
                ，就可能走回头路从而得到错误答案。在一个位置被匹配并且被标记后，我们可以同时递归调用四个回溯方法，即上下左右四个位置，并用｜｜连接它们来获得答案。这样的话好处在于将每个位置四个方向的递归查找
                同时进行比起一个个找要快得多，并且不影响正确性，因为当有任意一个方向找到了答案该位置都返回true，四个方向都未6找到时就进行回溯处理或者回到主循环接着找下一个位置。
            </p>
            <img src = "./src/images/leetcode79.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/ target="blank" class = "leetcodelink">
                    80. Remove Duplicates from Sorted Array II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>移除多余元素</li>
                <li>覆盖多余元素</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                重点来看覆盖方法。既然要求常数时间，那么肯定是要覆盖或者删除原数组而不创建新的数据结构。要覆盖很简单，创建两个指针，一个总是指向当前遍历到的位置判断当前数字和上一个是否重复了，另一个指针则负责覆盖。如果没有重复将当前指针负值给
                覆盖指针，两个指针同时向前移动找下一个位置。如果有重复判断重复数量是否大于2了，如果没有两个指针向后移动，如果超过二，遍历指针照常移动而覆盖指针停止移动，这样即可达到去掉多余重复的目的。此外需要一个count变量
                来记录当前重复的个数，并在遍历指针获得一个不同值时将count重置为1重新开始计数，相对的遍历指针找到的一下个值如果相同则count++，count始终维持某个数字出现过的次数。这样一轮遍历后覆盖指针经过的所有位置正是我们需要的数组，
                注意该数组不包括p1所指的数字（不包后）。
            </p>
            <img src = "./src/images/leetcode80.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/search-in-rotated-sorted-array-ii/ target="blank" class = "leetcodelink">
                    81. Search in Rotated Sorted Array II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>无</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                此题为33题一道变形，唯一不同在于数组中允许重复。33题中我们通过比较nums【mid】和nums【end】大小关系来判断如何更新start和end，此题仍然可以沿用这一思路，不过对于nums【mid】等于nums【end】这种情况需要做特殊处理。因为有了不特定多个重复值，
                导致当mid处值和end处值相等时无法判断该往哪个方向走，例如311找3和1131找3两个情况，end和mid处值均相等然而一个目标在左侧一个在右侧。该如何单独处理呢，观察到该情况下target一定不可能是end处的值，否则就会在nums[mid] == target的判断中被找到
                而返回true。如果在第一次判断mid值被判定不等于target而mid值又与end值相等，则end值一定不会被匹配，所以可以放心的将end向前移动推动主循环跳过重复元素继续寻找。
            </p>
            <img src = "./src/images/leetcode81.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/ target="blank" class = "leetcodelink">
                    82. Remove Duplicates from Sorted List II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>无</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                可以用hashset来去重复但是速度较慢，重点看一轮双指针遍历和recursion迭代两种方法。首先双指针维护两个指针，一个cur从head开始负责去重复，另一个pre从head前一个位置开始去维护一个正确的无重复链表。当cur未监测到重复并且cur和pre两个指针相连时，说明没有问题直接向后移动两个指针到next位置。
                如果cur监测到下一个位置有重复，跳过所有重复元素来到该重复数值的最后一个节点。此时如果pre的下一个链接不是cur则说明发生了去重复，我们需要重新链接指针的位置，此时需要特别小心，pre目前指向上一个没有重复的节点，cur指向下一组重复节点中的最后一个节点。例如题目中的1，2，3，3，4，4，5此时pre
                指向2，cur指向第二个3，先连接pre到正确位置，pre。next = cur。next，此时pre已经指向第一个4，我们再把cur连接到同样的位置（pre。next或者cur。next）就可以了。注意先进行指针相对位置的连接操作再实际移动指针，避免空指针异常。再来看recursion的思路，核心思路是一致的，只维护一个指针head，
                当监测到下一个位置出现重复时进行去重复，直接将head移动到下一个新的数字出现的节点，递归调用以该节点作为head的方法。如果没有监测到重复，直接将head的下一个位置作为新的head进入递归调用。最后head即可自顶向下构建出整个无重复的链表。
            </p>
            <img src = "./src/images/leetcode82.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/remove-duplicates-from-sorted-list/submissions/ target="blank" class = "leetcodelink">
                    83. Remove Duplicates from Sorted List
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>一轮遍历</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                维护一个指针即可，当该指针非空并且指针一下个索引非空时检测指针处的值和下一个索引的值是否相同，如果相同说明发现了重复，将指针的下一个索引修改为下下个索引跳过重复的节点直到下一个节点的值不相同为止。此时移动指针来到正确的下一个索引上即可。例如
                1，1，2指针开始指向第一个1，因为下一个节点也为1重复，将1的下一个索引跳过一个1连接到2结束循环返回1，2。
            </p>
            <img src = "./src/images/leetcode83.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/partition-list/ target="blank" class = "leetcodelink">
                    86. Partition List
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>一轮遍历双指针</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                如果不用指针也可以构建两个全新的链表并通过一轮遍历完成构建，之后进行拼接操作一样可以通过，但是造成了空间浪费，我们完全可以通过指针复用原本存在的节点而仅仅是修改索引的位置。首先创建两个指针（注意记录头部）通过head遍历原始链表，当发现小于target的值时
                less指针的下一个引用即指向当前head所指向的节点，随后更新less指针。遇到大于等于target时一样将greater指针下一个引用指向当前head指向的节点并更新greater指针，这样没有创建任何新的节点而仅仅是通过更改索引构建了两个子链表。这里有一点要注意就是最后将greater
                指针的下一个引用指向null，否则会出现listnode cycle。举个例子，题目中1，4，3，2，5，2在完成遍历后两个子链表分别是1，2，2此时第二个2指向null因为原始链表该位置下一个就指向null，而4，3，5的一下个索引依然指向原始链表中最后一个二，也就是less链表的第二个2。
                我们接着进行拼接将less链表第二个二连接到greater链表第一个位置，此时less链表第二个2指向greater第一个4，4指向3，3指向5，5由于没有修改原始链接依然指回less第二个2就出现了cycle。在使用指针而不是创建新节点时务必注意首尾是否有未断开的链接，此题只需要将
                5的下一个链接断开（指向null）就可以解决问题。
            </p>
            <img src = "./src/images/leetcode86.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/merge-sorted-array/ target="blank" class = "leetcodelink">
                    88. Merge Sorted Array
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>双指针从前向后</li>
                <li>双指针从后向前</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                从前向后双指针的一个问题在于指针处的值会被覆盖，所以需要现将nums1拷贝下来然后每次从拷贝的nums1拿指针的值防止被覆盖，这样就浪费了空间。而从后向前双指针就避免了这个问题，因为我们总是可以保证两个指针处的值不被覆盖。明确这一点后就很简单，在nums1前m个值和nums2
                的n个值均未用尽时将两个指针分别指向它们的末尾，每次选两个指针处较大的值放到nums1尾部并将对应指针--，这样nums1从尾部向前构建一个合并后的有序数组。需要注意一个特殊情况即遍历完成后nums2中还有剩余数字时需要将剩余数字复制到nums1对应位置中。例如nums1为3，4，5，0，0
                而nums2为1，2时，遍历完成后nums1为3，4，3，4，5此时待添加位置为1，从位置1开始分别将nums2中2和1拷贝到nums1的1和0位置即可。当nums1中有剩余时不需要处理，因为我们本来就要返回nums1，例如1，2，3，0，0和4，5。遍历完成后nums2用尽nums1为1，2，3，4，5已经为有序了。
            </p>
            <img src = "./src/images/leetcode88.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/gray-code/ target="blank" class = "leetcodelink">
                    89. Gray Code
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>无</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                首先通过观察发现n每增加1时，数组中需要新添加的数字为所有之前数组中数字二进制表示加上一个1开头其余位置为0的长度为n的二进制数，比如n=1时添加（1+1）=11，n=2时添加（10+0）10和（10+0）10，n=3时添加（100+10）110，（100+11）111，（100+01）101，（100+00）100。换句话说
                我们每次新添加的数为一个以2的（n-1次方）为基底的数字加上前面所有已经存在数字。观察到这一点后实现很简单，首先添加0为第一个已经存在的数，大循环从1到n，每次更新基底为2的（i-1）次方，并将res中的数字从后向前遍历以此和基底相加后添加回res。这里注意2的（i-1）次方可以用math的pow
                api实现也可以用位运算更高效实现，2的（i-1）次方在位运算中等价于将1左移（i-1）位即 1 << （i-1）。
            </p>
            <img src = "./src/images/leetcode89.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/subsets-ii/ target="blank" class = "leetcodelink">
                    90. Subsets II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>无</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                同样是在回溯或者dfs的算法结构下要求去重复，我们已经看到此类问题的套路，单纯判断一个数是否和前一个数相等是无法保持正确性的，因为诸如（2，2）这种正确的组合也被去掉了。这类问题的一大解法是判断每一个递归调用层开始处的指针，也就是start和这一层其他调用栈处的指针（也就是i）的大小
                关系，当且仅当start=i时没有回溯发生，也可以理解为还没走过回头路，此时当nums【i】和nums【i-1】一致时也不能去重复，因为此时所有组合都是未见过的（因为没走过回头路）。而当i 大于start的其他有回溯发生过的分枝上则要去重复，因为此时当重复发生时该组合一定已经被之前的调用加入过答案了。
                理解递归或者回溯树状结构一个好方法就是画出每一层栈的树状结构。可以参照下图理解此题结构，可以看到每一层的start是一样的，下一层的start和i均加一，每一层向右方向i递增，和回溯代码完全一致。
            </p>
            <img src = "./src/images/leetcode90.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/wechat2.png" height = 600px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/decode-ways/ target="blank" class = "leetcodelink">
                    91. Decode Ways
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>动态规划</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                观察到整个字符串从左至右每两个连续字符串和第三个字符之间的关系是有规律可循的，主要取决于后一个字符是否为0和这两个字符组成的数字和26的大小关系。第二个不是0数字也小于26时第三个位置的组合为前两个字符组合数之和，例如226第一个2有一种走法，第二个2有两种走法，而6继承了他们两个的全部走法
                所以共3种走法。当第二个数不为0时从第二个数字到第三个的走法没有被切断所以第三个数继承了从第二个数字的走法，同理当组成数字小于等于26时第三个数字继承了第一个的走法。当任意一个条件不满足时第二个或者第一个数字到第三个的路径会被切断，两个都不满足时第三个数字没有可行的组合。
                了解核心思想后构建一个长度为len+1的数组从左至右按上述法则计算到最后一个位置的累计走法最后返回最后一个位置就是总的可能的走法或者组合。
            </p>
            <img src = "./src/images/leetcode91.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/reverse-linked-list-ii/ target="blank" class = "leetcodelink">
                    92. Reverse Linked List II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>遍历反转拼接</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                重点看第二种方法，要反转一对node不难想到双指针的思路，关键在于如何确保遍历能够进行下去。例如反转1，2，3，pre指向1，cur指向2，此时我把cur。next指向pre那么2就指向1，但是导致链表没法遍历了，因为1指向2而2指向1造成了循环。解决节点反转的方法是启用第三个节点专门用来记录cur节点的下一个节点
                从而避免cur下一个节点丢失，这样之后只需要将pre指向cur，cur指向第三个节点就完成了交换节点。其他要注意的是拼接操作有两个特定节点需要提前记录避免丢失，就是进入反转的前一个节点和进入反转的第一个节点，即此题中的1和2节点，因为拼接是需要将1连接到反转遍历完成后pre所在的位置也就是4，2连接到
                遍历完成后cur的位置也就是5，而4有刚刚被反转一路指向2，反转就完成了。注意在正确的位置进入反转循环即可。
            </p>
            <img src = "./src/images/leetcode92.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/restore-ip-addresses/ target="blank" class = "leetcodelink">
                    93. Restore IP Addresses
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dfs回溯</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                因为要找出路径上所有的可能情况，所以bt肯定是首选，更准确的说是用dfs。观察到ip的性质，总共只有四个部分并且除了一位数其他部分开头不能为0，三位数时不得大于255，我们需要在dfs时注意这些点。观察到我们每次需要在不越界的前提下取从index开始处的长度分别为1，2，3的三种不同截取方式，因此可以将三种情况合并为一个循环处理，
                section每次截取对应的string后进入判断，当是两位数或者三位数并且开头为0时或者三位数大于255时跳过该循环，其余情况对应更新index，count和当前string后进入下一个dfs查找。这里为了处理点的问题只有当count为0也就是第一次添加到当前的空string时不添加点，其余情况在前面添加一个点，这种处理点的方式还是相当巧妙的。
            </p>
            <img src = "./src/images/leetcode93.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/binary-tree-inorder-traversal/ target="blank" class = "leetcodelink">
                    94. Binary Tree Inorder Traversal
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>遍历法</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                递归很经典不再赘述了，重点看遍历法。要用遍历解决的难点在于如何track某一个节点的上一个节点，就比如左分支全部找完之后如何回到父节点继续找右分支呢？一种数据结构很好的适应了这种需求就是stack，其lifo的性质是我们在记录完某个节点后可以通过pop stack来拿到他的父节点。了解到用stack后主要问题就解决了。主要实现思路是在树没有遍历完成（向stack的添加过程未完成）
                或者stack不为空时进行一个循环，从根节点开始首先找左分支上的所有节点，穷尽后开始进行pop操作逆向拿到来的时候路径上的每一个节点，现将那个节点加入答案，再进入该节点右分支，完美符合题目inorder即左中右的要求。这里stack的作用和递归调用栈的作用一致，递归时return即相当于这里的pop将当前节点弹出栈的作用。这样每一轮循环可以总结为先穷尽左分支，之后沿着左分支返回并查看
                每一个节点是否有右分支，如果有进入右子树继续左中右操作，没有就进入下一轮循环通过pop stack继续拿到下一个未处理过的节点。
            </p>
            <img src = "./src/images/leetcode94.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/unique-binary-search-trees-ii/ target="blank" class = "leetcodelink">
                    95. Unique Binary Search Trees II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
                <li>dp</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                首先看递归，主要思路在于当一个数作为根节点时，他的左子树根节点一定是所有小于他的数字所组成的，同理右子树根节点只能存在于大于他的所有数字中，而以这个节点为根节点的所有树的可能性等于以他为根所有左子树可能+以他为根所有右子树可能。了解这一点后我们就可以自顶向下暴力迭代以每一个范围内数字为根的所有可能性。递归方法设置两个参数start和end，初始范围自然是从1到n，每次从当前根节点分为左子树（s，i-1）
                和右子树（i+1，e）做一轮循环，相当于将范围内所有点作为根节点拆分为左右子树。但要得到每个节点处总的组合个数还需要将左右子树的所有情况组合并加入答案。dp的思路主要在于根据之前已有的组合和当前新加入的节点做组合并加入答案，如此循环n次。观察到在之前的已有的组合基础上每次新加入的n总是最大的，这就导致n只能加在根节点处或者之前组合某个节点的右孩子，并将那个节点之前的左孩子连接到新节点的右孩子（新节点总是最大的）。
                在之前已有组合上添加就需要创建一个之前已有组合的复制并在复制基础上添加新的n节点，保证不破坏已有组合。我们知道某个组合要找到待插入右孩子的位置最多需要向右找n-1次，我们可以对之前每一次组合都向右找n-1次并在第一次达到null时提前结束，这样就确保找到了旧组合上待插入新节点的位置。之后进行拼接将原先连接待插入节点右边子树剪下来，插入新节点为右孩子并将剪下的原右子树拼接在新节点左子树，这样一个新的组合就处理完毕加入答案。
                整理一下就是对于每个旧组合探究其每个旧组合可以插入新节点作为右孩子的所有节点，每找到一个就诞生一个新组合加入答案，这个找右孩子插入点的搜索最多有n-1次。（树为右链接linkedlist时需要找n-1次）。
            </p>
            <img src = "./src/images/leetcode95-1.png" height = 500px, width = 1200px alt = "leetcode"/>
            <img src = "./src/images/leetcode95-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/unique-binary-search-trees/submissions/ target="blank" class = "leetcodelink">
                    96. Unique Binary Search Trees
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                此题与上一题类似，n总共有多少种组合取决于从1到n每一个数字作为根节点时组合数之和。根据上一题我们知道每一点作为根节点时他的所有组合可以用他的所有可能左子树和右子树组合得到，这里因为只要求个数所以所谓组合其实就是乘积的关系，例如n=3时以2作为根节点时其组合数就是1作为根节点组合数乘以3作为节点组合数。但是当我们从2去推3的时候我们不知道3此时是多少，然而又需要3作为根节点时的组合数，怎么办呢。此题使用了一个基于对称思想的巧妙办法，
                例如题目中123假如我们此时知道1和2作为根节点组合数，3本来要用1，2和3作为根的和来得到但是我们还不知道3，但是我们知道3和1的组合数肯定是一样的，或者说树其实不一样但是完全对称的所以组合数一样。有了这种思想我们就总是可以从前n-1个已知根节点组合数推导出第n个数组合数，dp也就完成了。通俗来讲当我们需要用到包括n的倒数k个节点组合数之和时就把这k个数映射到前k个数，从已知的前半部分数组得到未知的后半部分数组节点和。
            </p>
            <img src = "./src/images/leetcode96.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/validate-binary-search-tree/ target="blank" class = "leetcodelink">
                    98. Validate Binary Search Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>recursion</li>
                <li>inorder traverse</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                二叉树的性质满足对于每一个节点，所有其左子树上的节点小于它，所有其右子树上的节点大于它。观察到仅仅对于每一个节点满足左小右大并不一定在全局上满足上述条件。接着观察到每一个节点的值都可以根据它的父节点推测出它的范围，我们可以设置上限和下限两个参数，在遍历树的同时实时更新每个节点上下限并检查每个节点的值是否落在正确的范围内。初始值设为正无穷和负无穷，注意用long来避免edge case，然后就可以进入递归了。那么每次如何更新上下限呢，
                观察到比如我们来到一个非空的节点，它的左节点下限不变和上限变为了该节点的值，因为要确保左小右大的原则。同理向右时上限不变而下限提高为该节点值。有了这个框架就可以进入递归主体了，每次先判断非空，然后判断是否越界了，一旦有返回false，其余递归左右分支并在返回值均为true时才返回true，用&&连接。此题另一种思路是沿用94题inorder traverse的遍历思想并充分利用inorder的性质，既然是左中右遍历也就是说如果是bst的话读取顺序一定是有序的，并且是
                升序的，也就是说我们在读取时一旦碰到一个比上一个数小或者相等，此树必然不是bst。
            </p>
            <img src = "./src/images/leetcode98.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=hhttps://leetcode.com/problems/same-tree/submissions/ target="blank" class = "leetcodelink">
                    100. Same Tree
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>递归</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                首先想到同时遍历两棵树，并且每次向左走还是向右走也保持一致，时时观察此时两棵树节点是否一致，如果都一致则树相等，否则不想等。两棵树可用递归同时遍历，当节点不一致时返回false，当同时为空时返回true，当仅有一个为空时说明不想等返回false。其余情况递归调用两棵树的左右子树并仅在左右子树均返回true时返回true，可以用&&连接两个递归调用的返回值来做到这一点。
            </p>
            <img src = "./src/images/leetcode100.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>