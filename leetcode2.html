<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/maximum-subarray/ target="blank" class = "leetcodelink">
                    53. Maximum Subarray
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>分治</li>
                <li>贪心</li>
                <li>动态规划</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                分治是一种可行的思路，不断将原始数组拆分成左半边右半边和跨越两边的总数组，迭代地寻找三个数组中最大的，最后返回的数字就是全局最大的答案，此方法时间复杂度不算最优，重点分析下后两种方法。
                贪婪的核心思想是每一步去局部最优解进而在最后得到全局最优解。这里储存两个变量，一个当前最大连续和，一个全局最大和，接着遍历数组，每次顺次更新这两个变量最后得到的全局最大和就是答案。动态规划
                在这里和贪心没有太大区别，核心思路是一致的。贪婪每次将当前最大和更新为当前看到的数字和此数字和当前局部最大和之和两者中的较大者（max（nums【i】，nums【i】+curr）），相当于用简单的取max
                操作省去了一个当前curr是否小于0的判断，亦或是第三种方法中nums【i-1】是否大于0的判断。另一个区别是第三种没有使用变量存贮当前最大和而是将局部最大和随着nums的遍历一起更新到nums【i】中了。
                从另一个角度考虑，当前curr小于0的时候只能将curr更新成当前看到的数字，因为无论这个数字是正还是负，这个数字都大于它自己与curr之和。当curr大于0时，统统加上当前看到的数字即可，即使这个数字
                是负数也不影响全局最大和的正确性。例如curr为2，看到一个-3，将curr更新为-1看似小了实则没有影响因为全局max已经看到过2了，只需要保证增大时能够正确更新即可。推荐如下写法，清晰易懂，这种写法和第二三种思路完全是等价的。
            </p>
            <img src = "./src/images/leetcode53.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/spiral-matrix/ target="blank" class = "leetcodelink">
                    54. Spiral Matrix
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>模拟</li>
                <li>按照螺旋层添加</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                认为第二种思路更自然，重点分析下。首先通过观察发现这个题可以用一个分成四部分的大循环完成遍历，这四部分分别为，最上面一行从左至右添加，最右边一列从上到下添加，最下边一行从右至左添加，
                以及最左边一行从下至上添加。并且要注意不重复和顺序的问题，自然联想到可以用四个指针记录这上下左右四个界的变动情况来达到这个目的。实现起来也不太难，每种情况都是用一个小的循环完成即可。
                有两点需要特别注意，第一点是在上下界或者左右界相等（相遇）时不要终止循环，否则会漏掉中间的一层。第二点是最上面一层左到右和最右边一层上到下两个小循环完成之后，其余两个小循环在进入
                前可能已经达到了终止条件，需要再次判断下是否应当立即结束循环。例如1-9的数组转完一圈之后上下左右都是1，进入第二轮大循环添加5，此时本来应当结束了，可是此时左右都为1，因此继续执行
                最下面一行从右向左添加，5就被加了两次。疏忽这一点会导致最后一次左到右添加的数又被从右向左添加一次（也可能是下到上重复）。解决方法简单，后两个小循环进入前判断下，如果出现左大于右或者
                上大于下立即结束即可。
            </p>
            <img src = "./src/images/leetcode54.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/jump-game/ target="blank" class = "leetcodelink">
                    55. Jump Game
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>回溯</li>
                <li>自顶向下动态规划</li>
                <li>自底向上动态规划</li>
                <li>贪婪</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                动态规划比较容易想到，但在这里不是最优解，因为我们只要知道能不能跳到最后，不是所有能跳过去的路径，因此bt在这里浪费时间了。再来看动态规划，这里dp结合了缓存的思想来尽可能为bt加速，核心原理是普通bt
                进行了很多无谓的比较，不如曾经到达过的某些位置明明已知无法到达重点，却在回溯过程中被重复考虑可能性，为此可以用一张表来记录访问过的位置的可达性，如果回溯到某个已知不可达的位置直接跳过，这就是自顶向下
                dp的核心思路。自底向上dp的核心思想在于我们直接不需要回溯这个框架了，充分利用了此类问题的方向行。如果从右向左找，我们每次一定可以确实地把一个位置标记为可达或者不可达，因为不可能重新回到右边，所以回溯也就没有
                意义了。最后一个位置一开始就是可达自己的，向前遍历时每次判断一个位置在它可触及的范围内是否有一个可达终点的位置，有说明他自身也是可达终点的，如此类推最后得到从起点是否可达终点。贪婪则是直接连记录某个位置
                是否可达都放弃了，充分利用了此题只需找出任意一种可能性的特点。从前向后或者反着都可以，向前核心思想是找出从当前可以向后延伸到的最远位置，在这些位置里找出能延伸的更远的位置，以此类推逐步向后推进最后判断是否
                达到了终点。反之亦然，每次向前找到可达终点的位置，逐步缩小末尾位置，如果最后末尾达到0就说明起点可达终点。可以想像起点和终点一个往后够，一个往前够，如果最终能达到彼此就说明可达。
            </p>
            <img src = "./src/images/leetcode55.png" height = 500px, width = 1200px alt = "leetcode"/>
            <hr>
        </section>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/merge-intervals/ target="blank" class = "leetcodelink">
                    56. Merge Intervals
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>暴力解法</li>
                <li>排序后一轮循环</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                主要难点在于如何排序，推荐评论区看到的一种java8 lambda表达式一行的写法，答案则是创建了一个继承了comparator接口的类并重写了compare方法，比较繁琐。按照数组首个数字排好序后就比较简单了，为了不修改原有数组创建一个新的
                空的list和一个指针newinterval，newinterval初始值为第一个数组直接加入res（在循环中加入也可以），每次遍历跟当前数组做比较。如果有overlap的情况，判断是否需要变更newinterval。注意不是所有overlap的情况都需要变更指针，例如1，4和2，3对比，虽然重合
                但是无需更新指针，为了方便可以将newinterval的第二个位置直接更新为指针第二个位置和当前数组第二个位置的最大者。这样1，4碰到2，3依然保持1，4，而1，3碰到2，6就更新为1，6保证了正确性。如果没有overlap的现象发生则把指针
                指向的数组添加进答案就向后移动指针，即把当前数组复制给指针，然后进入下一次遍历。注意顺序，否则会丢失指针原有的引用。最后将list of array转换为2d array返回即可。
            </p>
            <img src = "./src/images/leetcode56.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/length-of-last-word/ target="blank" class = "leetcodelink">
                    58. Length of Last Word
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>操作下标</li>
                <li>一轮循环</li>
                <li>内置函数</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                很容易想到内置函数indexof，但是字符串结尾有一个或者多个0时会干扰到indexof的判断，提前将结尾的0截掉即可。不使用内置函数也可以用循环找出最后一个非空格数字的下标，并从那里向前找到第一个空格为止计算长度。
                第二种思路将第一种中的两个循环合并成一个循环，从结尾向前找当找到一个非空格时记录这一串字符长度，当找到一个空格并且已经记录过长度时退出循环返回这个长度，其余情况即是仍然在遍历尾部的空格中。
            </p>
            <img src = "./src/images/leetcode58.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/spiral-matrix-ii/ target="blank" class = "leetcodelink">
                    59. Spiral Matrix II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>无</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                和54题思路基本雷同。提前构建空的二维数组和四个指针，最上面一行，最下面一行，最左边一列和最右边一列，并在主螺旋循环中的每个边循环完成后更新对应的值，这样即可做到不充不漏的遍历整个矩阵。依然是注意最下面一行右到左
                循环和最左边一列下到上循环进入前可能已经达到终止条件，需要提前判断避免重复。其余就是每次边循环放入一个自增的变量即可。
            </p>
            <img src = "./src/images/leetcode59.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/permutation-sequence/ target="blank" class = "leetcodelink">
                    60. Permutation Sequence
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>映射法（找规律）</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                答案的思路是根据阶乘的性质将每个排序映射为一个基于阶乘系统的表示法，评论区看到一种核心思路一致但更简洁自然的想法。首先我们为了得到目标排序，需要知道目标每一位上对应的是哪个数字，这是有规律可循的，规律的提供者正是阶乘的性质。
                注意到从左至右以每个数字开头的一组排序个数为（n-1）的阶乘个，没向后移动一位，以相同数字开头的排序组缩小为上一个数减1的阶乘个，一次类推。比如1，2，3，4的排序，以1为开头组的排序共有1，2，3，4；1，2，4，3；1，3，2，4；1，3，4，2；
                1，4，2，3；1，4，3，2六个，这一大组又以第二个数子分成三个小组，比如1，2开头的共有两个，1，3开头两个以此类推。利用排序阶乘这一性质我们可以定位到k个排序的每个位置分别对应哪个数字。注意由于题目中k是从1开始，所以需要减去1才能和
                位置下标完美对应。先看第一位，我们知道所有排序按照第一位数字分成了（n-1）阶乘个排序的组，那么自然想到用k/（n-1）！就可得到第一位数字对应的下标（所在第几组）。例如想找第八个排序的第一位，7/6=1，那么第一位就是数组下标1的数字也就是2。
                接着更新k位k%（n-1）！，（n-1）！更新为（n-2）！就进入了定位2开头所在的组的第二个位置数字的问题。取模运算得到此时下一层中每组排序个数，更新阶乘只需要除以当前剩余未使用的数字个数即可。用链表存贮初始数组，每定位一个位置数字就将该数字
                移除链表，保持相对位置正确性。当所有数字都没使用后结束循环，此时已经找到了目标位置的完整字符串。此题十分巧妙的利用了排序中阶乘的性质。

            </p>
            <img src = "./src/images/leetcode60.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/rotate-list/ target="blank" class = "leetcodelink">
                    61. Rotate List
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>转接链表</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                思路还是很清晰的，首先为了正确找到需要转接的位置，需要计算链表的长度，然后用k对长度取模即可。其次就是注意两个指针的位置，一次从头开始（最好不移动head，创建一个新指针），移动到
                转接点并构建一个子链表，一个从转接点开始移动到末尾，然后将末尾node连接到头部指针即可。注意转接点位置需要单独记录否则会在遍历到末尾的过程中丢失。链表为空的情况需要特殊处理。
            </p>
            <img src = "./src/images/leetcode61.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/unique-paths/ target="blank" class = "leetcodelink">
                    62. Unique Paths
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                经典dp问题，创建一个二维数组，初始化第一行和第一列为1（到达这些位置只有一种走法），然后遍历数组，剩下每个位置的走法数量为上面位置和左面位置走法数量之和。遍历结束后最右下角的
                走法数量就是总的走法。答案将整个数组一起初始化为一个充满1的数组，调用了arrays api的fill方法，可以节省一些时间。
            </p>
            <img src = "./src/images/leetcode62.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/unique-paths-ii/ target="blank" class = "leetcodelink">
                    63. Unique Paths II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                上一道题的变形，障碍物的位置自然为0，那么障碍物会对其他位置的路径有什么影响呢。注意到如果障碍物不在第一行或者第一列上的时候对它们右边和下面的路径是没有影响的，因为右边和下边位置依然遵循
                左边路径+上边路径的法则。只有在第一行或者第一列的时候障碍会导致所有右边或者下边路径均为0。所以这两种情况时我们将法则稍作改变即可。原本障碍物位置路径为0这一点不变，这些位置的路径是不可被改变的。
                我们可以将目标矩阵初始化时障碍物位置为0，其他位置1，遍历矩阵时跳过障碍物位置保持0，不在第一行或者第一列时保持左+上法则。在第一行列的时候将路径数直接从左边或者上边继承，这样没碰到障碍时
                保持1的状态，碰到后所有右边或者下边位置都将为0。注意0，0这个点要特殊处理，否则因为该点不存在左和上位置会抛出indexoutofbound错误。
            </p>
            <img src = "./src/images/leetcode63.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/minimum-path-sum/ target="blank" class = "leetcodelink">
                    64. Minimum Path Sum
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
                <li>原地dp</li>
            </ul>
            <h3>思路整理</h3>
            <p>
                因为可以在原理更改数组得到答案所以没必要特意构建新的数组浪费空间。基本思路很简单，遍历数组，左上角保持不变，第一行和第一列计算方式为自己加左边或者上边。其余位置
                计算方式为取自己加左边和自己加上面二者中较小值。如此这般遍历完成后最短路径就在右下角位置。经典dp题型。
            </p>
            <img src = "./src/images/leetcode64.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>