<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href="https://leetcode.com/problems/two-sum/" target="blank" class = "leetcodelink">
                    1.Two Sum
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>双重循环，比较简单略过</li>
                <li>两次循环的hashmap实现，第一次循环把键值对一次放入，第二次循环查找。</li>
                <li>一次循环的hashmap实现</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                比较容易想到双循环的思路，但复杂度n方不是最优解。我首先想到的是思路二两次循环hashmap，速度从74ms提升至2ms。这里需要
                注意的是判断目标数字下标位置时需要避开当前位置。举个例子【3，6，3】target = 6时不注意的话第一个3会匹配到自己而不是第二个
                3。第三个思路巧妙在于不直接一股脑把键值对全塞进去，而是仅在当前元素没查到对应值时才把当前元素和下标存入hashmap。举个例子
                官方例子中首先检查2，没查到7于是2，0键值对进入hashmap，接着检查7就直接查到了满足条件的键2于是算法直接返回。此方法阻止了
                在构建整个hashmap时无谓的浪费时间，将速度提升至1ms。
            </p>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/add-two-numbers/ target="blank" class = "leetcodelink">
                    2.Add Two Numbers
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>构建新链表，每个listnode的值依次为两个链表值之和。如果有进位则记录在carry中并在下一次循环时算入总和，最后如果两个链表遍历均完成仍有carry，在结果末尾链接新listnode值为carry。</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                经典链表操作，创建head和curr，curr指向head，通过移动curr构建链表，head用于保存头部位置方便返回结果。难点在于边界条件处理。同时遍历两个链表，只要其中一个没有遍历完就不终止循环，遍历完成的
                链表listnode值算为0。这其实是一种化繁为简，避免了考虑长度不相等的边界条件。要注意的是已经遍历完成的链表指针是停止移动的，否则会抛出npe，因为null是没有next属性的。最后不要忽略了长度相等
                遍历完成时carry不是0的情况，要在结果末尾额外添加一个值为1的listnode。
            </p>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/longest-substring-without-repeating-characters/ target="blank" class = "leetcodelink">
                    3. Longest Substring Without Repeating Characters
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>暴力解法，略过</li>
                <li>经典滑动窗口遍历法，i，j一头一尾通过在不同情况下更新 i和 j的值至 i+1或 j+1完成对所有符合要求子字符串的遍历。</li>
                <li>方法三为方法二的优化使用了hashmap存储char和下标键值对，每次跳跃更新 i的值以达到更快速度。</li>
            <h3>思路整理：</h3>
            <img src = "./src/images/leetcode3.png" height = 500px, width = 1200px alt = "leetcode"/>
            <p>
                我首先想到并通过的解法，但可以看到速度并不算很快。字符串操作速度肯定不如hashset来的快，所以判断重复肯定用hashset是最快的。除此之外我的方法应该和官方答案方法二是等效的，因为都一定要
                完整遍历完整个字符串。至于为什么答案用了双边窗口而这种方法只有单边是因为答案二使用 i和 j配合完成对set的更新，而同样的更新如果用字符串完全可以只用一个标记 i就完成更新。方法三的巧妙之处
                在于跳过了一些不需要考虑的情况。就拿最简单的b c a a举例子，方法二遍历到第二个a是发现重复了，但此时集合里有b c a必须依次删除所有元素直到集合里没有a，也就是要删除三次。实际上完全可以把
                标记i的下标直接从0也就是b移动到3也就是第二个a的位置，效果是相同的。而要达到这种效果必要的是记录每个char的下标所以很自然想到用hashmap存储char和下标的键值对。另外一点就是我发现答案三
                的写法有点迷惑因为hashmap存放的并不是直接的键值对而是char和下标位置+1，这样做应该是为了更新i时不用+1但感觉有点本末倒置。如下写法一样可以通过。
            </p>
            <img src = "./src/images/leetcode3-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/longest-palindromic-substring/ target="blank" class = "leetcodelink">
                    5. Longest Palindromic Substring
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>方法一提到可以找s和s的reverse s‘的最长公共字串，但是这种方法存在一个问题。</li>
                <li>方法二暴力解法略过，复杂度太高。</li>
                <li>方法三提到动态规划，暂时不做讨论。</li>
                <li>重点看下方法四中心扩展方法。</li>
                <li>方法五一种巧解，不用太过纠结这种解法，没见过的一定做不出来。</li>
            <h3>思路整理：</h3>
            <p>
                我一开始尝试用双指针窗口遍历解决，但很快发现不现实因为没法做到实时更新窗口大小。比如说abcb明显不是回文数但在遍历到最后一个char之前无法判断，因为后面依然可能跟一个a。
                至少在遍历完s长度一半之前完全不能判断如何更改窗口。怎么才能实时跟踪一个string是否还是回文数并更新窗口大小呢。很自然想到中心扩展，每次往两边扩展一个字符（前提是不越界）
                一旦新加入的字符左右不相等便可以立刻断定不是回文数了，即返回当前长度。另一个巧妙之处在于处理回文数中心在两个字符中间的问题，答案巧妙的利用一轮遍历解决了这两种情况，即i
                从0到长度-1，每次依次将窗口两侧指针的初始下标设定为i，i或者i，i+1，这样遍历即可囊括所有可能性。下面贴出我借鉴答案思路后自行完成的版本，引入了一个max变量判读是否为最长
                子串。
            </p>
            <img src = "./src/images/leetcode5.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/zigzag-conversion/ target="blank" class = "leetcodelink">
                    6. ZigZag Conversion
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>方法一行锁定法</li>
                <li>方法二官方叫做行访问法，其实我觉得叫行构建法更直观，因为该方法的答案string是顺序构建出来的。</li>
            <h3>思路整理：</h3>
            <p>
                这种找规律为主的题对数学基础好的应该不难。我首先就发现了规律并按照取模运算的规律做出如下写法，但可见速度很慢。问题在于遍历时没有优化，遍历了很多不需要遍历的字符。
            </p>
            <img src = "./src/images/leetcode6.png" height = 500px, width = 1200px alt = "leetcode"/>
            <p>
                参考答案二的思路，我完全可以省略第二个循环里的if判断而直接定位到要append的字符。核心思路还是一样的，找到了原始字符串每n * 2 - 2个字符为一组的规律。方法二主要的优化在于在第二轮循环中j 基于i当前的
                位置直接定位到需要append的位置。答案表示把整个string分成三部分即第一行的，最后一行的和其他所有中间的。我感觉这种说法有点迷惑，因为其实所有纵列上的字符被append进入答案时逻辑是相同的而只有处于斜线上的
                字符是通过内循环中的if判断进入答案的。所以说分成两大类即纵列上的和斜线上的我认为更合适。
                
                再看答案一，核心思路是先构建出所有的非空行，注意如果string长度比n还要小的情况即可。此时的状态可以看成是构建了刚刚好个数的stringbuilder待写入。剩下需要做的就是遍历完整string并依次判断哪个字符需要append
                到哪一行，即填充到哪个待填充的stringbuilder中去。使用两个变量当前行数和当前方向来定位需要填充到哪一行。curow初始值为0，初始方向为向上，每次到达第一行或者最后一行改变方向，每次更新curow需要参考方向的boolean值，
                向上即-1，向下即+1，可谓是很自然。两个变量在大循环中互相配合把每个字符append到对应的行中。最后把所有行的stringbuilder串起来就大功告成。个人认为这种想法不是很自然。
            </p>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/reverse-integer/discuss/4060/My-accepted-15-lines-of-code-for-Java target="blank" class = "leetcodelink">
                    7. Reverse Integer
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>官方解法略迷，推荐下链接里的解法。</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                这位老哥巧妙运用了在不overflow的前提下数学算式算式的恒等变换恒成立这一性质。说白了就是就是对一个数做了什么操作得到了什么结果，对结果你操作就应该得回那个数。如果不是就只能说明发生了overflow。还有一个朴实点的方法
                就是用long来存储答案，当答案越过int的存储界限时返回0。最后强制转型成int返回，不然会因为损失精度报错（其实没有损失，只是java不支持不安全的转型）。如下：
            </p>
            <img src = "./src/images/leetcode7.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/string-to-integer-atoi/ target="blank" class = "leetcodelink">
                    8. String to Integer (atoi)
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>官方没有解法。</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                非常无聊的一个ifelse练习，只有几个地方要注意。第一去掉空格可以用trim方法，这样可以不用单独去判断空格。第二正负号的判断，正号判断意义不明但是依然要做判断，注意只需要在去掉空格后判断一次即可，后面出现再多正负号也和字母一样当作杂音处理
                立刻返回结果即可。第三是整数overflow判断，预先把结果保存在long变量中，在返回前判断是否overflow即可。
            </p>
            <img src = "./src/images/leetcode8.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>