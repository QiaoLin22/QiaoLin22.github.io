<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href="https://leetcode.com/problems/two-sum/" target="blank" class = "leetcodelink">
                    1.Two Sum
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>双重循环，比较简单略过</li>
                <li>两次循环的hashmap实现，第一次循环把键值对一次放入，第二次循环查找。</li>
                <li>一次循环的hashmap实现</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                比较容易想到双循环的思路，但复杂度n方不是最优解。我首先想到的是思路二两次循环hashmap，速度从74ms提升至2ms。这里需要
                注意的是判断目标数字下标位置时需要避开当前位置。举个例子【3，6，3】target = 6时不注意的话第一个3会匹配到自己而不是第二个
                3。第三个思路巧妙在于不直接一股脑把键值对全塞进去，而是仅在当前元素没查到对应值时才把当前元素和下标存入hashmap。举个例子
                官方例子中首先检查2，没查到7于是2，0键值对进入hashmap，接着检查7就直接查到了满足条件的键2于是算法直接返回。此方法阻止了
                在构建整个hashmap时无谓的浪费时间，将速度提升至1ms。
            </p>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/add-two-numbers/ target="blank" class = "leetcodelink">
                    2.Add Two Numbers
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>构建新链表，每个listnode的值依次为两个链表值之和。如果有进位则记录在carry中并在下一次循环时算入总和，最后如果两个链表遍历均完成仍有carry，在结果末尾链接新listnode值为carry。</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                经典链表操作，创建head和curr，curr指向head，通过移动curr构建链表，head用于保存头部位置方便返回结果。难点在于边界条件处理。同时遍历两个链表，只要其中一个没有遍历完就不终止循环，遍历完成的
                链表listnode值算为0。这其实是一种化繁为简，避免了考虑长度不相等的边界条件。要注意的是已经遍历完成的链表指针是停止移动的，否则会抛出npe，因为null是没有next属性的。最后不要忽略了长度相等
                遍历完成时carry不是0的情况，要在结果末尾额外添加一个值为1的listnode。
            </p>
        </section>

        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/longest-substring-without-repeating-characters/ target="blank" class = "leetcodelink">
                    3. Longest Substring Without Repeating Characters
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>暴力解法，略过</li>
                <li>经典滑动窗口遍历法，i，j一头一尾通过在不同情况下更新 i和 j的值至 i+1或 j+1完成对所有符合要求子字符串的遍历。</li>
                <li>方法三为方法二的优化使用了hashmap存储char和下标键值对，每次跳跃更新 i的值以达到更快速度。</li>
            <h3>思路整理：</h3>
            <img src = "./src/images/leetcode3.png" height = 500px, width = 1200px alt = "leetcode"/>
            <p>
                我首先想到并通过的解法，但可以看到速度并不算很快。字符串操作速度肯定不如hashset来的快，所以判断重复肯定用hashset是最快的。除此之外我的方法应该和官方答案方法二是等效的，因为都一定要
                完整遍历完整个字符串。至于为什么答案用了双边窗口而这种方法只有单边是因为答案二使用 i和 j配合完成对set的更新，而同样的更新如果用字符串完全可以只用一个标记 i就完成更新。方法三的巧妙之处
                在于跳过了一些不需要考虑的情况。就拿最简单的b c a a举例子，方法二遍历到第二个a是发现重复了，但此时集合里有b c a必须依次删除所有元素直到集合里没有a，也就是要删除三次。实际上完全可以把
                标记i的下标直接从0也就是b移动到3也就是第二个a的位置，效果是相同的。而要达到这种效果必要的是记录每个char的下标所以很自然想到用hashmap存储char和下标的键值对。另外一点就是我发现答案三
                的写法有点迷惑因为hashmap存放的并不是直接的键值对而是char和下标位置+1，这样做应该是为了更新i时不用+1但感觉有点本末倒置。如下写法一样可以通过。
            </p>
            <img src = "./src/images/leetcode3-2.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>

        <section class = "section">
            <h2>
                <a href= https://leetcode.com/problems/longest-palindromic-substring/ target="blank" class = "leetcodelink">
                    5. Longest Palindromic Substring
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>方法一提到可以找s和s的reverse s‘的最长公共字串，但是这种方法存在一个问题。</li>
                <li>方法二暴力解法略过，复杂度太高。</li>
                <li>方法三提到动态规划，暂时不做讨论。</li>
                <li>重点看下方法四中心扩展方法。</li>
                <li>方法五一种巧解，不用太过纠结这种解法，没见过的一定做不出来。</li>
            <h3>思路整理：</h3>
            <p>
                我一开始尝试用双指针窗口遍历解决，但很快发现不现实因为没法做到实时更新窗口大小。比如说abcb明显不是回文数但在遍历到最后一个char之前无法判断，因为后面依然可能跟一个a。
                至少在遍历完s长度一半之前完全不能判断如何更改窗口。怎么才能实时跟踪一个string是否还是回文数并更新窗口大小呢。很自然想到中心扩展，每次往两边扩展一个字符（前提是不越界）
                一旦新加入的字符左右不相等便可以立刻断定不是回文数了，即返回当前长度。另一个巧妙之处在于处理回文数中心在两个字符中间的问题，答案巧妙的利用一轮遍历解决了这两种情况，即i
                从0到长度-1，每次依次将窗口两侧指针的初始下标设定为i，i或者i，i+1，这样遍历即可囊括所有可能性。下面贴出我借鉴答案思路后自行完成的版本，引入了一个max变量判读是否为最长
                子串。
            </p>
            <img src = "./src/images/leetcode5.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>