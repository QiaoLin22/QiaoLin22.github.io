<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href="https://leetcode.com/problems/two-sum/" target="blank" class = "leetcodelink">
                    1.Two Sum
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>双重循环，比较简单略过</li>
                <li>两次循环的hashmap实现，第一次循环把键值对一次放入，第二次循环查找。</li>
                <li>一次循环的hashmap实现</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                比较容易想到双循环的思路，但复杂度n方不是最优解。我首先想到的是思路二两次循环hashmap，速度从74ms提升至2ms。这里需要
                注意的是判断目标数字下标位置时需要避开当前位置。举个例子【3，6，3】target = 6时不注意的话第一个3会匹配到自己而不是第二个
                3。第三个思路巧妙在于不直接一股脑把键值对全塞进去，而是仅在当前元素没查到对应值时才把当前元素和下标存入hashmap。举个例子
                官方例子中首先检查2，没查到7于是2，0键值对进入hashmap，接着检查7就直接查到了满足条件的键2于是算法直接返回。此方法阻止了
                在构建整个hashmap时无谓的浪费时间，将速度提升至1ms。
            </p>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/add-two-numbers/ target="blank" class = "leetcodelink">
                    2.Add Two Numbers
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>构建新链表，每个listnode的值依次为两个链表值之和。如果有进位则记录在carry中并在下一次循环时算入总和，最后如果两个链表遍历均完成仍有carry，在结果末尾链接新listnode值为carry。</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                经典链表操作，创建head和curr，curr指向head，通过移动curr构建链表，head用于保存头部位置方便返回结果。难点在于边界条件处理。同时遍历两个链表，只要其中一个没有遍历完就不终止循环，遍历完成的
                链表listnode值算为0。这其实是一种化繁为简，避免了考虑长度不相等的边界条件。要注意的是已经遍历完成的链表指针是停止移动的，否则会抛出npe，因为null是没有next属性的。最后不要忽略了长度相等
                遍历完成时carry不是0的情况，要在结果末尾额外添加一个值为1的listnode。
            </p>
        </section>
    </main>
</body>
</html>