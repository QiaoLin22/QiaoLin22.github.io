<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
          <li class = "link"><a href = "./leetcode4.html">4</a></li>
          <li class = "link"><a href = "./leetcode5.html">5</a></li>
          <li class = "link"><a href = "./leetcode6.html">6</a></li>
          <li class = "link"><a href = "./leetcode7.html">7</a></li>
          <li class = "link"><a href = "./leetcode8.html">8</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/is-subsequence/ target="blank" class = "leetcodelink">
                    392. Is Subsequence
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                two pointers
            </ul>
            <h3>思路整理：</h3>
            <p>
                典型two pointer 可解的问题，两个pointer p1和p2都为0，分别指向s和t的第0个index。当p1和p2均未达到s和t的长度时（未越界）,依次比较s.charAt(p1)和t.charAt(p2)，相同时将p1和p2均向后移动一位，因为此时两个位置匹配，即
                同时向后推进寻找下一处匹配。当p1和p2对应index处字符不相同时，p2向后推进一位而p1保持不动，因为我们的最终目的在于找出s是否是t的subsequence，因此不能跳过s中的字符。循环结束后若s为t的subsequence，则p1必然等于s的长度，
                因此返回 p1 == s.length()即可，如果不相等则不是subsequence。
            </p>    
            <img src = "./src/images/leetcode392.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/kth-largest-element-in-a-stream/ target="blank" class = "leetcodelink">
                    703. Kth Largest Element in a Stream
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                two pointers
            </ul>
            <h3>思路整理：</h3>
            <p>
                看到stream和第k大自然想到priorityqueue，非常适合此题的场景。先写add方法，此处要点在于维护pq的大小恒定为k，现将val加入pq，之后检查若pq大小超过k则pop，之后return pq的队列顶元素也就是当前队列最小元素，也就是我们要的
                第k大的元素。有了这个add方法后我们可以在constructor中直接调用该add方法构建初始pq，将nums中的数字装进pq并维持pq大小为k。
            </p>    
            <img src = "./src/images/leetcode703.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>