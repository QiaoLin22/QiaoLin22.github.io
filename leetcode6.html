<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="style.css">
    <title>Leetcode Blogs</title>
</head>
<body>
    <header class = "header">
        <h1 class = "header-title">Leetcode Blogs</h1>
      </header>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './index.html'>Home</a></li>
          <li class = "link"><a href = "https://github.com/QiaoLin22" target = "blank">GitHub</a></li>
          <li class = "link"><a href = './leetcode.html'>Leetcode</a></li>
        </ul>
      </nav>
      <nav class = "leetcodenav">
        <ul class = "link-list">
          <li class = "link"><a href = './leetcode.html'>1</a></li>
          <li class = "link"><a href = "./leetcode2.html">2</a></li>
          <li class = "link"><a href = "./leetcode3.html">3</a></li>
          <li class = "link"><a href = "./leetcode4.html">4</a></li>
          <li class = "link"><a href = "./leetcode5.html">5</a></li>
          <li class = "link"><a href = "./leetcode6.html">6</a></li>
        </ul>
      </nav>
    <main class = "leetcodemain">
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/missing-number/ target="blank" class = "leetcodelink">
                    268. Missing Number
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>gaussian formula</li>
                <li>bit</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                用高斯求和算出应该有的总合后减去实际有的总合就可以直接得到漏掉的数字。或者使用bit manipulation方法，观察到从缺失的那一位开始index都比实际数字少1，我们可以利用这个性质。先将missing value设置为nums.length。然后遍历nums数组将missing
                每次分别和index i以及实际数字 nums[i] 做xor运算。结果是不缺失的数字都是成对出现于是两两相消，最后只剩下未消掉的缺失数字，也就是答案。
            </p>    
            <img src = "./src/images/leetcode268.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/closest-binary-search-tree-value/ target="blank" class = "leetcodelink">
                    270. Closest Binary Search Tree Value
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>inorder recursive</li>
                <li>binary search</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                最先想到inorder recursive，简单暴力，由于没有helper当root为空时返回距离target最远距离，其他情况比较root值，左子树返回值以及右子树返回值（recursive）并返回距离target最近的值即可。并一种更简洁并且充分利用bst性质的方法是binary search，在root节点
                不为空时持续向下寻找，每次通过判断当前root值于target大小关系决定向左边还是右边寻找，距离target最近的节点值必然存在于这条路径中，在搜索途中维护一个全局最接近target值，最后作为结果返回即可。
            </p>    
            <img src = "./src/images/leetcode270.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/encode-and-decode-strings/ target="blank" class = "leetcodelink">
                    271. Encode and Decode Strings
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>Chunked Transfer Encoding</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                思路很有意思一道题，encode所采用的策略是将list中的每个string的长度信息和string本身一起encode进一个string里（注意长度string和substring本身需要用一个非数字字符分隔开方便之后拆分），相对的decode时每次根据一下个要拆分的string长度信息结合indexof方法定位
                substring的位置。decode具体做法为设置一个指针初始值为0，在i指针未达到s结尾时进行while循环，每次调用indexof方法直接得到下个分隔字符位置index1（字符前面为位置信息，后面为substring本身）。我们知道从i到index为储存位置信息的字符段，用integer的valueof方法拿到下个substring长度（len）后就可以通过substring
                index+1到index+1+len直接拿到substring本身。这样一个substring的decode就结束了，将i指针移动到下个substirng长度信息字符串开始位置，即index+1+len即可。
            </p>    
            <img src = "./src/images/leetcode271.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/h-index/ target="blank" class = "leetcodelink">
                    274. H-Index
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>sort</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                画图有助于理解此题，题目问的其实就是在x轴index和每个citation值组成的图形中最大的正方形边长。有了这个思路后自然要对数组排序，之后从i等于0进行搜索，当i不越界以及citations[citations.length - 1 - i] > i时向右移动i。最后返回i即可，i即是我们要的index h。
            </p>    
            <img src = "./src/images/leetcode274.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/h-index-ii/ target="blank" class = "leetcodelink">
                    275. H-Index II
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>binary search</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                此题沿用了上题核心思路，即寻找数组中出现的第一个满足条件citations[i] >= n - i 的数字，再加上数组有序自然想到二分。具体实现二分很简单见下图，找到后返回数组长度-start即使题目要求的h index。
            </p>    
            <img src = "./src/images/leetcode275.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/paint-fence/ target="blank" class = "leetcodelink">
                    276. Paint Fence
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                一看就是dp的套路，但想到点上不那么容易，重点是理清思路。观察到对于每个n来说，组成总paint的数量可以拆分成两部分，即最后连个房子是同种颜色和最后两个房子是不同颜色，观察到这点可以使问题大大简化，因为我们可以在dp时将这两个情况分开考虑从而避开出现多于2个相邻房子同种
                颜色的情况。先看base case，当n为1时自然有k种方法，n为2也是base case，从这里我们就要将前两个房子相同和不同颜色的情况分开计算了，不同颜色自然是k*（k-1）种，相同则还是k种，比较直接。从第三个房子到第n个房子就是我们dp的范围了。从第三个房子开始，我们每次分别更新
                diffCount和sameCount。我们知道，截止到上一个房子，第i-1个房子时paint的总数为 diffCount+sameCount，又知道当前第i个房子和上个颜色不同，那么新diffCount自然为(sameCount + diffCount) * (k-1)。再看sameCount的情况，这里要注意的点是避开出现三个连续同色
                的房子，方法很简单，我们不能从之前的sameCount继承任何paint法，因为都将造成三个同色，因此只能从之前diffCount继承，又知道和上个房子同色，因此新的sameCount和旧diffCount数量是相同的。注意到这点就简单了，直接将原diffCount提前保存后负值给新sameCount。到此一轮
                dp就更新完毕，接着只要循环即可。最后总的paint数量为截止到第n个房子的sameCount和diffCount数量之和。
            </p>    
            <img src = "./src/images/leetcode276.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/find-the-celebrity/ target="blank" class = "leetcodelink">
                    277. Find the Celebrity
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>Logical Deduction</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                此题注意到关键逻辑点就不难。注意到每次我们调用knows（int a，int b） api的时候根据celebriy的定义都可以排除a 或者 b其中一个人是celebrity的可能性。我们知道作为celebrity，必须不认识除了自己外的其他人，同时其他人全部认识他。那么每次调用knows进行询问的时候
                只有两个可能。第一，a认识b，那么a必然不是celebrity。第二，a不认识b，那么b必然不是celebrity。既然每次调用knows都可以确实排除一个人，我们只需要从第0个人开始（0是初始候选人）到n依次调用knows询问当前候选人和下一个人直接是否认识就一定可以通过一轮遍历将候选人缩小至一个人，
                因为题目给出最多一个celebrity（或者没有）。确定这个最终候选人后还没有结束，该候选人未必一定是celebrity，因为我们并没有将所有人两两配对调用knows，所以依然可能该候选人a认识其他人或者有其他人不认识他，只是我们没有对那个组合进行询问。这个也好解决，最后单独对a进行一轮遍历，
                检查是否有他不认识的人或者别人不认识他，如果有那么a也不是celebrity，那么只能是不存在celebrity，返回-1.如果通过了检查，那么a确实是celebrity，返回a。
            </p>    
            <img src = "./src/images/leetcode277.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/first-bad-version/ target="blank" class = "leetcodelink">
                    278. First Bad Version
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>binary search</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                明显的二分，题目比较简单，按照二分标准套路来就行。
            </p>    
            <img src = "./src/images/leetcode278.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/perfect-squares/ target="blank" class = "leetcodelink">
                    279. Perfect Squares
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>dp</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                比较明显的dp，关键在于发现如何从前n-1个位置推导出第n个位置。观察到由于每个数字都是由若干perfect square所组成，那么第n个位置数字一定也是由之前某个位置数字+一个不超过n的perfect square组成，而该perfect square的数量是有限且
                确定的，例如12，不超过它的perfect square只有1，4，9三个，那么第12个位置数字必然由位置11数字+1或者位置8数字+1，或者位置3数字+1得来，而我们需要的是找到这若干种情况中最小的数字并把它作为第n位置数字。还是12的例子，位置11数字+1是
                4，位置8数字+1为3，位置3数字+1为4，所以位置12数字是3。该dp方法遍历长度为n数组，每次确定第n个位置数字时又从sqrt（n）个候选人中遍历得出最小，因此总复杂度为o（n根号n）。
            </p>    
            <img src = "./src/images/leetcode279.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/wiggle-sort/ target="blank" class = "leetcodelink">
                    280. Wiggle Sort
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>one pass</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                观察到大小关系的顺序为从左至右偶数位上的数字小于等于奇数位上的数字，奇数位上的数字大于等于偶数位上的数字。那么我们从左至右一轮遍历，检查对应位置上的两个数字大小关系是否不符合要求，如果不符合，那么将两个数字互换即可。交换全部完成后原数组必然为
                wiggle sort（评论区有严格证明）。时间为o（n），空间为in place。
            </p>    
            <img src = "./src/images/leetcode280.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/zigzag-iterator/ target="blank" class = "leetcodelink">
                    281. Zigzag Iterator
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>two pointer</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                首先想到双指针法，两个指针依次在两个数组上遍历，当两个指针有任何一个未达到末尾时说明zigzag iteration未完成，也就是hasnext会return true。next方法我们需要一个boolean 变量flag来标记当前处在哪个数组之中，true表示第一个数组，false表示第二个数组。
                当数组数量从2扩展到任何k的时候可以用boolean 变量down 和 up来表示。当两个指针均为达到终点时在两个数组之间zigzag 遍历，每次返回当前指针数字后更改flag为！flag。当有一个数组到达终点时在另一个数组上直接遍历到终点即可。注意两个指针，数组和flag都是全局变量。
            </p>    
            <img src = "./src/images/leetcode281.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
        <hr>
        <section class = "section">
            <h2>
                <a href=https://leetcode.com/problems/move-zeroes/ target="blank" class = "leetcodelink">
                    283. Move Zeroes
                </a>
            </h2>
            <h3>官方思路:</h3>
            <ul>
                <li>one pass swap</li>
            </ul>
            <h3>思路整理：</h3>
            <p>
                不改动数组意味着基本就是swap，关键在于怎么swap，题目要求在保持非0数字相对位置不变的前提下将所有0移动到数组末端。我们从头扫描数组，同时设置一个指针j初始值为0，j之前的数字全部不为0，而j之后的不确定。每次从j开始向后找到下一个不为0的数字，将其位置i与j互换后j++。一轮
                遍历后所有不为0数字会按顺序被交换到所有0前面且相对位置不变，正满足题目要求。
            </p>    
            <img src = "./src/images/leetcode283.png" height = 500px, width = 1200px alt = "leetcode"/>
        </section>
    </main>
</body>
</html>